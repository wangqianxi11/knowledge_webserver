---
title: SqlConnRAII类
updated: 2025-05-19T22:58:54
created: 2025-04-07T15:32:42
---

**RAII，资源获取即初始化，将在使用前获取（分配的堆内存、执行线程、打开的套接字、数据库连接等有限资源）的资源的生命周期与某个对象的生命周期绑定在一起。**

确保在控制对象的生命周期结束时，按照资源获取的相反顺序释放所有资源

同样，如果资源获取失败（构造函数退出并带有异常），按照初始化相反顺序释放所有已完全构造成员和基类子对象所获取的资源。

RAII的原理：
**利用栈上局部变量的自动析构来保证资源一定会被释放。**

平常在C++编程过程中，会忘了释放资源，会导致内存泄漏。

但是变量的析构函数的调用是由编译器保证，一定会被执行，所以如果资源的获取和释放与对象的构造和析构绑定在一起，就不会出现资源泄露问题。

**实现步骤：**
- 设计一个类封装资源，比如内存、文件、socket、锁等
- 在构造函数中执行资源的初始化，比如申请内存、打开文件、申请锁
- 在析构函数中执行销毁操作、比如释放内存、关闭文件、释放锁
- 使用时，声明一个该对象的类

### RAII模式构造时资源获取，析构时资源释放，只负责连接生命周期管理，不涉及具体数据库操作
```c++
#ifndef SQLCONNRAII_H

#define SQLCONNRAII_H

#include "sqlconnpool.h"

/* 资源在对象构造初始化 资源在对象析构时释放*/

class SqlConnRAII {

public:

// 构造函数：执行资源的初始化

    SqlConnRAII(MYSQL** sql, SqlConnPool *connpool) {

        *sql = connpool->GetConn(); // 获取连接

        sql_ = *sql; // 保存连接指针

        connpool_ = connpool; // 保存连接池指针

    }

// 析构函数：执行销毁操作

    ~SqlConnRAII() {

        if(sql_) { connpool_->FreeConn(sql_); } // 不为空指针，则归还连接

    }

private:

    MYSQL *sql_;

    SqlConnPool* connpool_;

};

#endif //SQLCONNRAII_H
```

### 一、为什么使用 RAII 管理数据库连接？
**1. 自动释放资源，避免泄漏**
数据库连接是一种昂贵的资源，如果使用后没有手动释放（归还给连接池），将导致连接耗尽。RAII 通过对象生命周期自动释放资源，不依赖程序员手动 release()。

**2. 异常安全**
如果中途抛出异常，比如 SQL 查询异常，手动释放连接的代码可能不会执行。而 RAII 的析构函数会自动被调用，确保资源释放。

**3. 逻辑清晰，易于维护**
RAII 模板将“获取”和“释放”操作封装在一个类中，调用者只需获取连接，其他交由类本身管理，提高代码可读性和稳定性。

