---
title: 代码解析
updated: 2025-04-07T15:28:53
created: 2025-04-07T15:02:42
---

**初始化和单例访问，单例模式避免重复创建连接池**
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p></th>
<th><p>SqlConnPool::SqlConnPool() {</p>
<p>// 构造函数，初始化成员变量</p>
<p>useCount_ = 0;</p>
<p>freeCount_ = 0;</p>
<p>}</p>
<p></p>
<p>SqlConnPool* SqlConnPool::Instance() {</p>
<p>// 单例模式，确保整个程序只有一个连接池实例</p>
<p>// 第一次调用创建静态局部变量,后续调用都返回同一个实例的指针</p>
<p>static SqlConnPool connPool;</p>
<p>return &amp;connPool;</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**Init()函数连接池的初始化函数，负责建立初始的数据库连接池。包括创建连接池、配置连接参数和初始化同步机制。**
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p></th>
<th><p>void SqlConnPool::Init(const char* host, int port,</p>
<p>const char* user,const char* pwd, const char* dbName,</p>
<p>int connSize = 10) {</p>
<p>/*</p>
<p>@host：数据库地址</p>
<p>@port：端口</p>
<p>@user：用户名</p>
<p>@pwd：密码</p>
<p>@dbName：数据库名</p>
<p>@connSize：连接池大小</p>
<p>*/</p>
<p>for (int i = 0; i &lt; connSize; i++) {</p>
<p>MYSQL *sql = nullptr;</p>
<p>sql = mysql_init(sql); // 初始化MySQL结构体</p>
<p>if (!sql) {</p>
<p>LOG_ERROR("MySql init error!");</p>
<p>}</p>
<p>sql = mysql_real_connect(sql, host,</p>
<p>user, pwd,</p>
<p>dbName, port, nullptr, 0); // 建立实际连接</p>
<p>if (!sql) {</p>
<p>LOG_ERROR("MySql Connect error!");</p>
<p>}</p>
<p>connQue_.push(sql); // 成功建立的连接放入队列</p>
<p>}</p>
<p>MAX_CONN_ = connSize; // 记录最大连接数</p>
<p>sem_init(&amp;semId_, 0, MAX_CONN_); // 初始化信号量，初始值是最大连接数数</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**GetConn()函数从连接池中获取一个可用的MySQL数据库连接，使用同步机制保证多线程安全访问。**
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p></th>
<th><p>MYSQL* SqlConnPool::GetConn() {</p>
<p>MYSQL *sql = nullptr;</p>
<p>if(connQue_.empty()){</p>
<p>LOG_WARN("SqlConnPool busy!");</p>
<p>return nullptr;</p>
<p>}</p>
<p>// 信号量控制总连接数，互斥锁保护队列操作</p>
<p>sem_wait(&amp;semId_); // 获取信号量，没有回阻塞</p>
<p>{</p>
<p>lock_guard&lt;mutex&gt; locker(mtx_);</p>
<p>sql = connQue_.front();</p>
<p>connQue_.pop();</p>
<p>} // 使用互斥锁保护连接队列</p>
<p>return sql;</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**FreeConn()函数将使用完毕的数据库连接归还给连接池**
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p></th>
<th><p>void SqlConnPool::FreeConn(MYSQL* sql) {</p>
<p>lock_guard&lt;mutex&gt; locker(mtx_); // 构造时加锁、析构时解锁</p>
<p>connQue_.push(sql); // 将连接重新放回连接队列</p>
<p>sem_post(&amp;semId_); // 增加信号量计数</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**ClosePool()函数关闭整个数据库连接池**
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p></th>
<th><p>void SqlConnPool::ClosePool() {</p>
<p>lock_guard&lt;mutex&gt; locker(mtx_); // 使用RAII模式的lock_guard自动管理锁生命周期</p>
<p>while(!connQue_.empty()) {</p>
<p>// 循环直到队列为空</p>
<p>auto item = connQue_.front();</p>
<p>connQue_.pop();</p>
<p>mysql_close(item);</p>
<p>}</p>
<p>mysql_library_end(); // 终止数据库</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

