---
title: 日志系统
updated: 2025-04-07T17:18:52
created: 2025-04-07T16:31:52
---

**构造函数，初始化成员变量**
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p></th>
<th><p>Log::Log() {</p>
<p>lineCount_ = 0; // 记录当前日志行，从0开始</p>
<p>isAsync_ = false; // 标志日志是否为异步模式</p>
<p>writeThread_ = nullptr; // 异步写日志的线程指针</p>
<p>deque_ = nullptr; // 异步模式下使用的阻塞队列指针</p>
<p>toDay_ = 0; // 当前日志的日期</p>
<p>fp_ = nullptr; // 日志文件指针</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**析构函数，日志销毁时清理资源**
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p></th>
<th><p>Log::~Log() {</p>
<p>// 异步日志清理,</p>
<p>if(writeThread_ &amp;&amp; writeThread_-&gt;joinable()) {</p>
<p>while(!deque_-&gt;empty()) {</p>
<p>deque_-&gt;flush(); // 确保队列中剩余内容被清理</p>
<p>};</p>
<p>deque_-&gt;Close();</p>
<p>writeThread_-&gt;join(); // 等待写进场结束</p>
<p>}</p>
<p></p>
<p>// 同步日志清理</p>
<p>if(fp_) {</p>
<p>lock_guard&lt;mutex&gt; locker(mtx_);</p>
<p>flush();</p>
<p>fclose(fp_);</p>
<p>}</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

日志系统的初始化，配置日志的输出级别，输出路径、日志后缀、双端队列大小
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p></th>
<th><p>void Log::init(int level = 1, const char* path, const char* suffix,</p>
<p>int maxQueueSize) {</p>
<p>/*</p>
<p>@level: 级别</p>
<p>@path: 输出路径</p>
<p>@suffix: 日志的后缀</p>
<p>@maxQueueSize: 日志队列的最大容量</p>
<p>*/</p>
<p>isOpen_ = true; // 日志打开标志</p>
<p>level_ = level; // 级别</p>
<p>if(maxQueueSize &gt; 0) { // 如果最大容量大于0，启用异步写入</p>
<p>isAsync_ = true; // 异步标志位</p>
<p>if(!deque_) {</p>
<p>unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; newDeque(new BlockDeque&lt;std::string&gt;);</p>
<p>deque_ = move(newDeque); // 创建一个阻塞双端队列</p>
<p>std::unique_ptr&lt;std::thread&gt; NewThread(new thread(FlushLogThread));</p>
<p>writeThread_ = move(NewThread); // 启动一个新的线程来处理日志的写入</p>
<p>}</p>
<p>} else {</p>
<p>isAsync_ = false;</p>
<p>}</p>
<p></p>
<p>lineCount_ = 0; // 设置第0行开始</p>
<p></p>
<p>time_t timer = time(nullptr);</p>
<p>struct tm *sysTime = localtime(&amp;timer);</p>
<p>struct tm t = *sysTime;</p>
<p>path_ = path;</p>
<p>suffix_ = suffix;</p>
<p>char fileName[LOG_NAME_LEN] = {0};</p>
<p>// 构造日志文件名,格式为path/YYYY_MM__DD_suffix,(年月日.后缀)</p>
<p>snprintf(fileName, LOG_NAME_LEN - 1, "%s/%04d_%02d_%02d%s",</p>
<p>path_, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, suffix_);</p>
<p>toDay_ = t.tm_mday;</p>
<p></p>
<p>{</p>
<p>// 使用互斥锁，保证线程安全</p>
<p>lock_guard&lt;mutex&gt; locker(mtx_);</p>
<p>buff_.RetrieveAll(); // 清空缓冲区buff</p>
<p>if(fp_) { // 如果文件已打开，刷新内容，并关闭</p>
<p>flush();</p>
<p>fclose(fp_);</p>
<p>}</p>
<p></p>
<p>fp_ = fopen(fileName, "a");</p>
<p>if(fp_ == nullptr) { // 如果文件不存在，则创建新的目标文件夹，在打开</p>
<p>mkdir(path_, 0777);</p>
<p>fp_ = fopen(fileName, "a");</p>
<p>}</p>
<p>}</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**日志的写入功能，支持日志文件按日期和行数切换**
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>60</p>
<p>61</p>
<p>62</p>
<p>63</p>
<p>64</p>
<p>65</p>
<p>66</p>
<p>67</p>
<p>68</p></th>
<th><p>void Log::write(int level, const char *format, ...) {</p>
<p>/*</p>
<p>@level: 日志的级别</p>
<p>@format: 格式化字符串，</p>
<p>*/</p>
<p>struct timeval now = {0, 0};</p>
<p>gettimeofday(&amp;now, nullptr);</p>
<p>time_t tSec = now.tv_sec;</p>
<p>struct tm *sysTime = localtime(&amp;tSec);</p>
<p>struct tm t = *sysTime;</p>
<p>va_list vaList;</p>
<p></p>
<p>/* 日志日期 日志行数 */</p>
<p>// 判断是否需要切换日志文件：1、日期不一致 2、行数达到最大值</p>
<p>if (toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_ % MAX_LINES == 0)))</p>
<p>{</p>
<p>unique_lock&lt;mutex&gt; locker(mtx_);</p>
<p>locker.unlock();</p>
<p>char newFile[LOG_NAME_LEN];</p>
<p>char tail[36] = {0};</p>
<p>snprintf(tail, 36, "%04d_%02d_%02d", t.tm_year + 1900, t.tm_mon + 1, t.tm_mday);</p>
<p></p>
<p>if (toDay_ != t.tm_mday)</p>
<p>{</p>
<p>// 如果不等于，构造新的日志文件名</p>
<p>snprintf(newFile, LOG_NAME_LEN - 72, "%s/%s%s", path_, tail, suffix_);</p>
<p>toDay_ = t.tm_mday;</p>
<p>lineCount_ = 0;</p>
<p>}</p>
<p>else {</p>
<p>snprintf(newFile, LOG_NAME_LEN - 72, "%s/%s-%d%s", path_, tail, (lineCount_ / MAX_LINES), suffix_);</p>
<p>}</p>
<p>locker.lock();</p>
<p>flush();</p>
<p>fclose(fp_);</p>
<p>fp_ = fopen(newFile, "a"); // 打开新的日志文件</p>
<p>}</p>
<p></p>
<p>{</p>
<p>unique_lock&lt;mutex&gt; locker(mtx_);</p>
<p>lineCount_++;</p>
<p>// 将时间戳和日志内容拼接到缓冲区</p>
<p>int n = snprintf(buff_.BeginWrite(), 128, "%d-%02d-%02d %02d:%02d:%02d.%06ld ",</p>
<p>t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,</p>
<p>t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec);</p>
<p>buff_.HasWritten(n);</p>
<p>AppendLogLevelTitle_(level); // 根据日志级别添加标题[info]、[error]</p>
<p></p>
<p>va_start(vaList, format);</p>
<p>int m = vsnprintf(buff_.BeginWrite(), buff_.WritableBytes(), format, vaList);</p>
<p>va_end(vaList);</p>
<p></p>
<p>buff_.HasWritten(m); // 使用vsnprintf将传入的格式化字符串format生成日志内容并写入缓冲区</p>
<p>buff_.Append("\n\0", 2);</p>
<p>// 如果启用异步写入，则将日志内容推送到队列中，等待其他线程进行写入</p>
<p>// 如果启用同步写入，或队列已满，则直接将日志内容写入到fp_中</p>
<p>if(isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;full()) {</p>
<p>deque_-&gt;push_back(buff_.RetrieveAllToStr());</p>
<p>} else {</p>
<p>fputs(buff_.Peek(), fp_);</p>
<p>}</p>
<p>buff_.RetrieveAll();</p>
<p>}</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

