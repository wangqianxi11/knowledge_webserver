## volatile
`volatile`提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序<b>每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。</b>

如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

一般说来，volatile用在如下的几个地方：

1、中断服务程序中修改的供其它程序检测的变量需要加volatile；

2、多任务环境下各任务间共享的标志应该加volatile；

3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。

## volatile 的含义
volatile总是与**优化**有关，编译器有一种技术叫做**数据流分析**，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以死代码消除。但有时这些优化不是程序所需要的，这时可以用**volatile关键字禁止做这些优化**，volatile的字面含义是易变的，它有下面的作用：

1 不会在两个操作之间把volatile变量缓存在寄存器中。在多任务、中断、甚至setjmp环境下，变量可能被其他的程序改变，编译器自己无法知道，volatile就是告诉编译器这种情况。

2 不做常量合并、常量传播等优化

3 对volatile变量的读写不会被优化掉。如果你对一个变量赋值但后面没用到，编译器常常可以省略那个赋值操作，然而对Memory Mapped IO的处理是不能这样优化的。

前面有人说volatile可以保证对内存操作的原子性，这种说法不大准确，其一，x86需要LOCK前缀才能在SMP下保证原子性，其二，RISC根本不能对内存直接运算，要保证原子性得用别的方法，如atomic_inc。

## 编译器优化 → C关键字volatile → memory破坏描述符
memory比较特殊，可能是内嵌汇编中最难懂部分。为解释清楚它，先介绍一下编译器的优化知识，再看C关键字volatile。最后去看该描述符。

### 1、编译器优化介绍

内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。

另外在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。

再看软件一级的优化：一种是在编写代码时由程序员优化，另一种是由编译器进行优化。

编译器优化常用的方法有：将**内存变量缓存到寄存器**；调整指令顺序充分利用CPU指令流水线，常见的是**重新排序读写指令**。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏解决编译器的执行顺序问题。

### volatile关键字的作用
volatile 关键字的作用是告诉编译器，该变量是易变的，不能进行优化。具体来说，volatile 关键字有以下几个作用：
#### 1) 防止编译器优化
编译器会对变量进行优化，以提高程序的性能。例如，编译器可能会把一个变量的值缓存到寄存器中，以避免频繁地读写内存。然而，在一些特定的场景中，变量的值可能会在程序的执行过程中被外部因素改变。

如果编译器对变量进行优化，可能会导致程序出现不可预测的错误。因此，使用volatile关键字可以告诉编译器不要对该变量进行优化，每次都要从内存中读取该变量的值。
#### 2) 强制编译器按照程序顺序访问变量
在一些特定的场景中，程序的正确性依赖于变量的读写顺序。例如，在多线程程序中，多个线程可能会同时访问同一个变量。如果编译器对变量进行了优化，可能会导致不同线程看到的变量值不一致，从而引发程序错误。

使用 volatile 关键字可以强制编译器按照程序顺序访问变量。具体来说，编译器会按照程序中变量的访问顺序来访问变量，而不是按照优化后的顺序来访问变量。
#### 3) 提供内存屏障
在一些特定的场景中，程序需要对变量的读写顺序进行严格的控制。例如，在多线程程序中，变量的读写顺序可能会影响程序的正确性。

为了保证程序的正确性，需要在变量的读写操作之间插入内存屏障（Memory Barrier），以确保变量的读写顺序符合程序的要求。

使用 volatile 关键字可以提供内存屏障，以确保变量的读写顺序符合程序的要求。具体来说，使用 volatile 关键字可以在变量的读写操作之间插入内存屏障，以确保变量的读写顺序符合程序的要求。


## volatile关键字的注意事项
在使用 volatile 关键字时，需要注意以下几点：
### 1) 不要滥用volatile关键字
虽然 volatile 关键字可以防止编译器优化，强制编译器按照程序顺序访问变量，提供内存屏障，但是不应该滥用 volatile 关键字。因为 volatile 关键字会影响程序的性能，使用<b>过多的 volatile 关键字会导致程序变慢。</b>
### 2) 不要依赖volatile关键字解决多线程问题
虽然 volatile 关键字可以防止编译器优化，强制编译器按照程序顺序访问变量，但是不应该依赖 volatile 关键字解决多线程问题。因为 volatile 关键字无法保证原子性，不能解决多线程竞争的问题。解决多线程竞争的问题需要使用其他的同步机制，比如互斥锁、读写锁、信号量等。
### 3) 注意多线程程序中的内存可见性问题
在多线程程序中，多个线程可能会同时访问同一个变量。为了保证程序的正确性，需要保证变量的内存可见性。具体来说，当一个线程修改了变量的值，其他线程应该能够立即看到变量的新值。

使用 volatile 关键字可以保证变量的内存可见性。具体来说，当一个线程修改了 volatile 变量的值，其他线程能够立即看到变量的新值。

但是需要注意的是，volatile 关键字只能保证单个变量的内存可见性，不能保证多个变量之间的内存可见性。如果多个变量之间存在依赖关系，需要使用其他的同步机制来保证变量之间的内存可见性。
### 4) 注意内存屏障的使用
在使用 volatile 关键字提供的内存屏障时，需要注意内存屏障的使用。具体来说，内存屏障应该放置在正确的位置，以确保变量的读写顺序符合程序的要求。如果内存屏障放置不当，可能会导致程序出现不可预测的错误。
### 5) 注意编译器的实现
不同编译器对 volatile 关键字的实现可能存在差异。因此，在使用 volatile 关键字时，需要注意编译器的实现。特别是在多平台开发中，不同平台上的编译器对 volatile 关键字的实现可能存在差异，需要谨慎处理。