---
title: 锁
updated: 2025-05-10T13:44:48
created: 2025-05-08T16:28:42
---

## 锁

操作系统层面的锁（如互斥锁）的核心实现机制是：<b>当线程无法获取锁时，它不是进行低效的“自旋”（忙等待），而是由操作系统将其状态置为“阻塞”（睡眠），并放入一个等待队列，然后切换执行其他线程。当锁被释放时，操作系统再唤醒等待队列中的线程。</b>

这是一种“用调度换效率”的策略，避免了CPU时间的浪费。
### 关键数据结构
要实现这个机制，操作系统内核中需要一个数据结构来代表一个锁。我们以最简单的互斥锁为例，它通常包含以下关键字段：
```c++
// 一个简化的内核互斥锁结构
struct kmutex {
    int locked;           // 锁状态：0-空闲，1-被占用
    struct task_list wait_queue; // 等待获取该锁的线程队列
    // ... 可能还有其他字段，如持有者信息、调试信息等
};
```
- `locked`：原子变量，表示锁的当前状态。
- `wait_queue`：一个链表，用于记录所有正在等待这个锁的线程（任务）。
### 底层原语：`futex (Fast Userspace muTEX)`
现代操作系统（如Linux）实现锁的基石是 futex。它的设计非常精妙，采用了“快速路径”和“慢速路径”相结合的方式。

- **快速路径**（用户态）：在无竞争或竞争很少的情况下，完全在用户态通过原子操作完成，无需进入内核，速度极快。

- **慢速路径**（内核态）：只有在真正需要挂起或唤醒线程时，才通过系统调用进入内核。
#### 场景一：获取锁（锁是空闲的）-> 快速路径
1. 线程A调用 `pthread_mutex_lock(&mutex)`。

2. 库函数在用户态使用一条原子比较并交换指令，尝试将 mutex 的值从0（空闲）改为1（占用）。

3. 操作成功！ 锁状态被原子性地更新，线程A成功获取锁。

4. 整个过程中，**没有发生系统调用**，线程始终在用户态运行。速度极快。
#### 场景二：获取锁（锁已被占用）-> 慢速路径
1. 线程B尝试获取已被线程A占用的锁。

2. 在用户态的原子操作失败后，它不会自旋，而是会执行一个系统调用（在Linux上是 FUTEX_WAIT）。

3. 进入内核态：
   - 内核再次检查锁的状态。（为什么再检查？因为从用户态检查完到进入内核的瞬间，锁可能已经被释放了，这是一个“竞态条件”）
   - 如果锁确实还被占用，内核会执行以下操作：
    - 将线程B的状态从 `TASK_RUNNING` 改为 `TASK_INTERRUPTIBLE`（可中断睡眠）。
    - 将线程B的 `task_struct`（进程控制块）加入到该锁的 `wait_queue` 中。
    - 调用调度器 `schedule()`，主动让出CPU。

4. 线程切换：调度器选择另一个就绪线程（比如线程C）来运行。线程B此刻完全停止执行，不消耗CPU。
#### 场景三：释放锁并唤醒等待者
1. 线程A执行 `pthread_mutex_unlock(&mutex)`。

2. 库函数在用户态使用原子操作将锁状态置为0。

3. 它发现 `wait_queue` 可能非空（通过检查一个标志位），于是执行 `FUTEX_WAKE` 系统调用。

4. 进入内核态：
   - 内核找到该锁对应的 `wait_queue`。
   - 从队列中取出一个或多个线程（例如线程B）。
   - 将这些线程的状态从 `TASK_INTERRUPTIBLE` 改回 `TASK_RUNNING`，并将它们从等待队列中移除，加入到调度器的就绪队列中。

5. 线程变为可运行：现在线程B又可以被调度器选中并执行了。当它再次被调度上CPU时，它会从之前进入睡眠的系统调用中返回，然后再次尝试获取锁（通常又会走一遍快速路径的原子操作）。

### mutex（互斥量）
mutex是最常见的多线程同步方式。思想：**多线程共享一个互斥量，线程之间去竞争**。得到锁的线程可以进入临界区执行代码
```c++
// 声明一个互斥量

pthread_mutex_t mtx;

// 初始化

pthread_mutex_init(&mtx, NULL);

// 加锁

pthread_mutex_lock(&mtx);

// 解锁

pthread_mutex_unlock(&mtx);

// 销毁

pthread_mutex_destroy(&mtx);
```
mutex是睡眠等待（sleep waiting）类型的锁，当线程抢互斥锁失败的时候，会陷入休眠。

**优点**：节省CPU资源

**缺点**：休眠唤醒会消耗一点时间

### 条件变量（condition variable）
条件变量不是锁，是线程间的通信机制，几乎总是和互斥量一起使用

### 读写锁
对于临界区区分读和写
也叫共享-独占锁，含义是：**读共享，写独占的锁**
**特性**：
- 加了写锁，其他进程对该锁加读锁或写锁都会**阻塞**
- 加了读锁，其他进程加写锁会阻塞，加读锁会成功
读写锁是一个锁，准确的说法，给读写锁加**读模式**和加**写模式**的锁
**用空间换时间**
### 自旋锁
通缩的解释**忙等待**，即**死循环**
当共享资源的状态不满足的时候，自旋锁会不停地循环检测状态，不会陷入休眠，也就不需要条件变量
- 不休眠就不会引起上下文切换
- 比较浪费CPU

### 乐观锁和悲观锁
#### 悲观锁
**核心思想**：假设冲突经常发生，每次访问共享资源时都先加锁。
**特点**：
- **获取锁时机**：操作数据前先获取锁
- **实现方式**：数据库行锁、表锁、Java的`​synchronized、​ReentrantLock`等
- **适用场景**：
  - 写操作多的场景
  - 冲突频率高的环境
  - 临界区执行时间长的操作

#### 乐观锁 (Optimistic Locking)
**核心思想**：假设冲突很少发生，只在提交操作时检查是否发生冲突。

**特点**：
- **获取锁时机**：先操作，提交时检查版本
- **实现方式**：版本号/时间戳、CAS操作
- **适用场景**：
  - 读多写少的场景
  - 冲突概率低的环境
  - 临界区执行时间短的操作

### 什么是CAS
**比较并替换**，需要有三个操作：内存地址V、旧的预期值A、即将更新的目标值B<br>
当前仅当V的值与预期值相等，将V的值修改为B，否则什么都不做，是一个原子操作

**CAS的缺点：**
CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。
1.  循环时间长开销很大。
2.  只能保证一个共享变量的原子操作。
3.  ABA问题。循环时间长开销很大：我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。

只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。

### 什么是ABA问题？ABA问题怎么解决？
CAS 的使用流程通常如下：

1）首先从地址 V 读取值 A； 

2）根据 A 计算目标值 B；

3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。

但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗？

如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。

