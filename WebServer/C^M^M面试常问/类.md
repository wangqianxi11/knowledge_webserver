---
title: 类
updated: 2025-08-22T19:04:09
created: 2025-04-15T11:25:40
---

# C++类 & 对象
C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。**类是 C++ 的核心特性，通常被称为用户定义的类型。**
类用于指定对象的形式，是一种用户自定义的数据类型，**它是一种封装了数据和函数的组合。**类中的数据称为成员变量，函数称为成员函数。类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。
## C++ 类定义
定义一个类需要使用关键字class，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。
定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。
![image1](../../resources/42df5fec14124f16a799f4453aab6cdb.png)

## 定义 C++ 对象
==类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：==
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p></th>
<th><p>Box Box1; // 声明 Box1，类型为 Box</p>
<p>Box Box2; // 声明 Box2，类型为 Box</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**==类 & 对象详解==**
==到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。==
| **概念** | **描述** |
|----|----|
| [类成员函数](https://www.runoob.com/cplusplus/cpp-class-member-functions.html) | 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 |
| [类访问修饰符](https://www.runoob.com/cplusplus/cpp-class-access-modifiers.html) | 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 |
| [构造函数 & 析构函数](https://www.runoob.com/cplusplus/cpp-constructor-destructor.html) | 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 |
| [C++ 拷贝构造函数](https://www.runoob.com/cplusplus/cpp-copy-constructor.html) | 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 |
| [C++ 友元函数](https://www.runoob.com/cplusplus/cpp-friend-functions.html) | **友元函数**可以访问类的 private 和 protected 成员。 |
| [C++ 内联函数](https://www.runoob.com/cplusplus/cpp-inline-functions.html) | 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 |
| [C++ 中的 this 指针](https://www.runoob.com/cplusplus/cpp-this-pointer.html) | 每个对象都有一个特殊的指针**this**，它指向对象本身。 |
| [C++ 中指向类的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-class.html) | 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 |
| [C++ 类的静态成员](https://www.runoob.com/cplusplus/cpp-static-members.html) | 类的数据成员和函数成员都可以被声明为静态的。 |

### 类成员函数
类的一个成员，可以操作类的任意对象，可以访问对象中的所有成员。
成员函数可以定义在类内部，或者单独使用**范围解析运算符::**定义。
在类定义中定义的成员函数把函数声明为内联的
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>class Box</p>
<p>{</p>
<p>public:</p>
<p>double length; // 长度</p>
<p>double breadth; // 宽度</p>
<p>double height; // 高度</p>
<p>double getVolume(void);// 返回体积</p>
<p>};</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
也可以在类的外部使用范围解析运算符定义，在::之前必须使用类名。
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>double Box::getVolume(void)</p>
<p>{</p>
<p>return length * breadth * height;</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
调用成员函数是在对象上使用点(.)运算符
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Box myBox; // 创建一个对象</p>
<p>myBox.getVolume(); // 调用该对象的成员函数</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
### 
类的生命周期
类从被加载到内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接
全局对象在main开始前被创建，main退出后被销毁。
静态对象在第一次进行作用域时被创建，在main退出后被销毁。
局部对象在进入作用域时被创建，在退出作用域时被销毁。
New创建的对象直到内存被释放的时候都存在。

### 类对象的构建顺序
1.  **基类（父类）**构造函数先于子类构造函数执行
2.  成员对象按**声明顺序**（不是初始化列表顺序）构造
3.  当前类的构造函数体最后执行
### 类对象的析构顺序
**与构造顺序相反：**
1.  **当前类的析构函数体先执行**
2.  **成员变量按 声明顺序的逆序 析构**
3.  **基类（父类）最后析构**

## 空类中有什么函数？
默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符
取值运算符、const取值运算符

## 类中static函数是否能声明为虚函数？
不能，因为类中的static函数是所有类实例化对象所共有的，没有this指针，而虚函数依靠vptr和vtable来处理，vptr是一个指针，在类中的构造函数中生成，并且只能通过this指针访问，对于静态成员函数来说，他没有this指针，无法访问vptr，因此static函数无法声明为虚函数

## 如何保证类的对象只能被开辟在堆上？（将构造函数声明为私有、单例）
将构造函数设置为私有，这样只能使用new运算符来建立对象，但是我们必须准备一个destory函数来进行内存的释放，然后将析构函数设置为protected，提供一个public的static函数来完成构造，类似于单例模式
如果在栈上分配呢？则是重载new操作符，使得new操作符的功能为空，这样就使得外层程序无法在堆上分配对象，只可以在栈上分配

## 讲讲你理解的虚基类
虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。
为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。
虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。
虚基类是可以被实例化的。
## C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？
auto仅仅只是一个占位符，在编译期间它会被真正的类型替代，或者说C++中变量必须要有明确类型的，只是这个类型是由编译器自己推导出来的。
函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式具体类型函数的模具，所以模板其实就是将原本应该我们做重复的事情交给了编译器。

