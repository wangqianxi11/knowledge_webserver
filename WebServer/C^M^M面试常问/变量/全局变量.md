## 全局变量
指<b>在函数外部定义的变量，它在整个程序的所有函数中都可以被访问和使用。</b>

核心特征是<b>全局可见性和静态生命周期。</b>

### 作用域（Scope）

全局变量在定义处开始到程序结束的范围内都有效。

可以被所有函数直接访问。

### 存储位置

全局变量存放在静态存储区（静态内存区），在程序运行期间始终存在。

### 生命周期

从程序开始运行到结束，全局变量一直存在，不会像局部变量一样随函数调用结束而销毁。


### 什么时候（谨慎地）使用全局变量？
全局变量的核心特征是全局可见性和静态生命周期。

#### 1. 真正的全局单例资源
当某个资源在程序中有且只有一个实例，并且需要被程序中许多不相关的部分广泛访问时。

经典例子：

- 硬件抽象：表示整个系统唯一存在的硬件。例如，extern UART_HandleTypeDef huart1;（STM32的串口1句柄）。整个程序的所有模块都需要通过它来访问这个特定的串口。

- 全局日志器：一个被所有模块用于记录日志的单一日志器对象。

- 主配置结构：一个在程序启动时加载、在运行时只读的配置对象，被整个程序读取。

#### 2. 性能关键的极致优化
在嵌入式系统或高性能计算中，为了避免频繁的函数参数传递（尤其是大的结构体），有时会使用全局变量来减少栈开销和复制时间。但这通常是优化到最后一步才考虑的手段。

#### 3. 中断服务程序（ISR）与主程序通信
在裸机嵌入式编程中，ISR（如定时器中断、串口接收中断）由于没有上下文，无法通过参数与主循环通信。通常使用一个全局标志位或缓冲区来传递信息。

#### 4. 内存极度受限的环境
在一些非常古老的系统或极低端的微控制器上，编译器或运行时环境可能非常简陋，避免使用全局变量的工程实践可能无法应用。


### 注意事项

#### 1. 命名冲突与污染全局命名空间
风险：项目很大时，很难保证全局变量名的唯一性。不同文件中的同名全局变量会导致链接错误或难以察觉的错误。

对策：

- 使用**冗长、描述性、具有唯一性**的名字（如 g_system_uart_handle 而不是 uart）。

- 在C语言中，使用 `static` 关键字将<b>全局变量的作用域限制在单个.c文件内（称为“文件作用域变量”）</b>，然后通过函数接口对外提供访问。这是最重要的实践之一。

#### 2. 耦合性与可维护性差
风险：任何函数都可以修改或依赖全局变量，导致函数之间通过隐藏的全局状态耦合在一起，而不是通过清晰的接口（参数和返回值）。这使得代码难以理解、测试和修改。修改一个全局变量可能产生“牵一发而动全身”的效应。

对策：如果必须用，那么就**尽量只读**。使用 `const` 修饰符声明全局常量。

#### 3. 非线程安全
风险：在多线程环境中，多个线程同时读写同一个全局变量会导致**数据竞争**，结果是未定义的且极难调试。

对策：必须使用**互斥锁、信号量**等同步机制来保护对全局变量的每一次访问。这增加了代码复杂度和性能开销。

#### 4. 可测试性差
风险：单元测试要求测试用例是隔离的。一个函数如果依赖于全局状态，那么每个测试用例开始前都需要重置这个状态，测试变得复杂且脆弱。

对策：依赖注入（Dependency Injection）。将依赖的资源作为参数传递给函数，而不是在函数内部直接访问全局变量。这样在测试时就可以轻松传入一个模拟对象（Mock）。

#### 5. 初始化顺序问题（C++尤其突出）
风险：在不同编译单元（.cpp文件）中定义的全局变量，它们的初始化顺序是未定义的。<b>如果一个全局变量的构造函数依赖于另一个已被构造的全局变量，程序可能会崩溃。</b>

对策：使用“首次使用时构造”的惯用法（Meyer's Singleton）。

#### 6. 对嵌入式系统：注意 `volatile` 关键字
风险：在中断服务程序（ISR）中修改、在主循环中读取的全局变量（如上面的标志位），编译器优化可能会将其缓存到寄存器中，导致主循环永远读不到变化后的值。

对策：必须使用 volatile 关键字声明该变量，告诉编译器这个变量可能被异步修改，禁止相关优化。