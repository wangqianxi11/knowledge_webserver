---
title: 虚函数
updated: 2025-08-22T16:15:52
created: 2025-04-15T10:44:20
---

在C++中，虚函数的实现原理基于两个关键概念：虚函数表和虚函数指针
- **虚函数表**：**每个包含虚函数的类都会生成一个虚函数表**，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。
- **虚函数指针**：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。
**当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。**

在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中

所谓虚函数就是在基类定义一个未实现的函数名，为了提高程序的可读性，建议后代中虚函数都加上<font color="blue">virtual</font>关键字。一般格式：
```c++
class base

{

public:

    base();

    virtual void test(); //定义的一个虚函数

private:

    char *basePStr;

};
```
常见用法：声明基类指针，利用指针指向任意一个子类对象，调用相关的虚函数，**动态绑定**，由于编写代码时不能确定被调用的是基类函数还是那个派生类函数，所以被称为“”虚“”函数。<br>
**如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。**

## 虚函数占用多少内存
一个虚函数本身不占用类的对象实例的内存。但是，为了实现虚函数机制，编译器会为包含虚函数的类生成一个“虚函数表”（vtable），并在每个对象实例中添加一个指向该表的指针（vptr）。这个指针在32位系统上占用 4 字节。

### 1. 虚函数本身在哪里？
虚函数是代码，和所有其他函数一样，编译后存储在程序的代码段（text segment） 中。<b>它不属于任何一个对象实例，因此不直接占用对象的内存空间。</b>

### 2. 虚函数机制的实现成本（内存开销）
虽然函数代码不占空间，但C++运行时的多态机制需要额外的数据结构来支持，这带来了内存开销。

#### 开销一：虚函数表（vtable）

编译器会为包含虚函数的类以及它的派生类各自创建一个虚函数表。

这个表是一个静态数组，存储着该类所有虚函数的函数指针。

<b>vtable本身是静态数据，存储在程序的静态数据区或只读数据区，不属于对象实例，因此不计入单个对象的大小。</b>

#### 开销二：虚函数表指针（vptr）

这是关键所在。编译器会隐式地在每一个包含虚函数的类的对象实例中插入一个隐藏的指针成员——<b>虚函数表指针（vptr）</b>。

这个 vptr 指向该类对应的虚函数表。

当程序调用 obj->virtual_function() 时，实际上是通过 obj->__vptr[index] 来找到正确的函数地址进行调用（这个过程称为动态绑定）。

#### 3. 32位系统上的大小
在32位系统上，一个指针的大小是 4 字节。

因此，<b>对于一个包含虚函数的类，它的每一个实例都会因为 vptr 而额外增加 4 字节 的开销。</b>

### 重要细节和特殊情况
#### 只有一个虚函数 vs 多个虚函数：

- <b>无论你有1个还是100个虚函数，对象的开销始终只是一个 vptr（4字节）。</b>增加虚函数只会使虚函数表（vtable）变大，但vtable是类共享的，不影响每个对象的大小。

#### 继承的影响：

- 在单继承体系中，一个类及其所有派生类通常只需要一个 vptr。派生类的vtable会包含自己的和基类的虚函数指针。

- 在多重继承中，情况变得复杂。一个派生类可能会包含<b>多个基类的子对象，因此可能包含多个 vptr。</b>例如，如果派生自两个各自包含虚函数的基类，那么这个派生类的对象很可能会有两个vptr，开销就是 8 字节。

#### 空类带有虚函数：

- C++规定任何对象的大小至少为1字节以确保其有唯一地址。

- 但如果一个空类声明了虚函数，它就需要vptr。在32位上，其大小就是4字节（vptr），而不是1字节。