---
title: 锁
updated: 2025-05-10T13:44:48
created: 2025-05-08T16:28:42
---

### mutex（互斥量）
mutex是最常见的多线程同步方式。思想：**多线程共享一个互斥量，线程之间去竞争**。得到锁的线程可以进入临界区执行代码
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p></th>
<th><p>// 声明一个互斥量</p>
<p>pthread_mutex_t mtx;</p>
<p>// 初始化</p>
<p>pthread_mutex_init(&amp;mtx, NULL);</p>
<p>// 加锁</p>
<p>pthread_mutex_lock(&amp;mtx);</p>
<p>// 解锁</p>
<p>pthread_mutex_unlock(&amp;mtx);</p>
<p>// 销毁</p>
<p>pthread_mutex_destroy(&amp;mtx);</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
mutex是睡眠等待（sleep waiting）类型的锁，当线程抢互斥锁失败的时候，会陷入休眠。
**优点**：节省CPU资源
**缺点**：休眠唤醒会消耗一点时间

### 条件变量（condition variable）
条件变量不是锁，是线程间的通信机制，几乎总是和互斥量一起使用

### 读写锁
对于临界区区分读和写
也叫共享-独占锁，含义是：**读共享，写独占的锁**
**特性**：
- 加了写锁，其他进程对该锁加读锁或写锁都会**阻塞**
- 加了读锁，其他进程加写锁会阻塞，加读锁会成功
读写锁是一个锁，准确的说法，给读写锁加**读模式**和加**写模式**的锁
**用空间换时间**
### 自旋锁
通缩的解释**忙等待**，即**死循环**
当共享资源的状态不满足的时候，自旋锁会不停地循环检测状态，不会陷入休眠，也就不需要条件变量
- 不休眠就不会引起上下文切换
- 比较浪费CPU

### 乐观锁和悲观锁
#### 悲观锁
**核心思想**：假设冲突经常发生，每次访问共享资源时都先加锁。
**特点**：
- **获取锁时机**：操作数据前先获取锁
- **实现方式**：数据库行锁、表锁、Java的==<sub></sub>​synchronized​<sub></sub>==、==<sub></sub>​ReentrantLock​<sub></sub>==等
- **适用场景**：
- 写操作多的场景
- 冲突频率高的环境
- 临界区执行时间长的操作

乐观锁 (Optimistic Locking)
**核心思想**：假设冲突很少发生，只在提交操作时检查是否发生冲突。
**特点**：
- **获取锁时机**：先操作，提交时检查版本
- **实现方式**：版本号/时间戳、CAS操作
- **适用场景**：
- 读多写少的场景
- 冲突概率低的环境
- 临界区执行时间短的操作

**什么是CAS**
**比较并替换**，需要有三个操作：内存地址V、旧的预期值A、即将更新的目标值B
当前仅当V的值与预期值相等，将V的值修改为B，否则什么都不做，是一个原子操作
**CAS的缺点：**
CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。
1.  循环时间长开销很大。
2.  只能保证一个共享变量的原子操作。
3.  [ABA问题](https://zhida.zhihu.com/search?content_id=6012562&content_type=Article&match_order=1&q=ABA%E9%97%AE%E9%A2%98&zhida_source=entity)。
循环时间长开销很大：我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。

只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。

什么是ABA问题？ABA问题怎么解决？
CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。
但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗？
如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。

