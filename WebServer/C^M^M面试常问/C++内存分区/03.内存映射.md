---
title: 内存映射
updated: 2025-08-22T18:43:13
created: 2025-04-15T11:05:31
---

mmap系统调用可以分配一段匿名的虚拟内存区域，也可以映射一个文件到内存，这个映射让文件操作像直接操作内存一样，这种方式称之为**内存映射**。

**mmap()必须以内存页（PAGE_SIZE）为单位进行映射**，而内存也只能以页为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先**进行内存对齐**，强行以PAGE_SIZE的倍数大小进行映射。

mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。在要求高性能的应用中比较常用，但在面向流的设备不能进行mmap，mmap的实现和硬件有关。

## 内存映射（Memory Mapping）详解

内存映射（Memory Mapping）是**一种将文件或设备直接映射到进程地址空间的技术**，使得程序可以像访问内存一样读写文件或硬件资源，而不需要传统的read()/write()系统调用。它广泛应用于文件 I/O 优化、进程间通信（IPC）、动态库加载等领域。

**1. 内存映射的基本概念**

**（1）什么是内存映射？**
- 定义：将文件或设备的一部分映射到进程的虚拟内存空间，使得程序可以直接通过指针访问文件内容，而无需显式调用read()/write()。
- **核心机制**：由操作系统管理，底层使用**页表**（Page Table）和<b>缺页中断（Page Fault）</b>实现按需加载。

**（2）主要用途**
- **高效文件 I/O**：减少用户态和内核态之间的数据拷贝（零拷贝技术）。
- **共享内存 IPC**：多个进程映射同一文件，实现高效数据共享。
- **动态库加载**：```.so```/```.dll```文件通过内存映射加载到进程空间。
- **大数据处理**：处理超大文件时，避免一次性加载整个文件。

### 静态链接库和动态链接库的区别
<style>
table th:first-of-type {
    width: 4cm;
}
table th:nth-of-type(2) {
    width: 150pt;
}
table th:nth-of-type(3) {
    width: 8cm;
}
</style>
| 特性       | 静态链接库（Static Library）                                                                  | 动态链接库（Dynamic Library / Shared Library）             |
| ---------- | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| 文件后缀   | .a (Unix/Linux), .lib (Windows)                                                               | .so (Linux), .dylib (macOS), .dll (Windows)                |
| 链接时机   | 编译时                                                                                        | 运行时                                                     |
| 行为方式   | 库的代码直接被复制到最终的可执行文件中                                                        | 库的代码不进入可执行文件，只在运行时被加载                 |
| 可执行文件 | 更大（因为包含了所有需要的库代码）                                                            | 更小（只包含对库的引用，不包括实际代码）                   |
| 内存占用   | 可能更高（如果多个程序使用同一库，每份程序都在内存中有该库的副本）                            | 更低（多个程序可以共享内存中的同一份库代码）               |
| 部署难度   | 简单：可执行文件是独立的，直接运行即可                                                        | 复杂：必须确保目标系统上安装了正确版本的动态库             |
| 更新与升级 | 困难：必须重新编译和链接整个程序                                                              | 容易：替换库文件即可（需注意版本兼容性），程序无需重新编译 |
| 运行速度   | 稍快（函数调用无额外开销，因为地址在编译时已确定）	稍慢（存在运行时加载和符号查找的微小开销） |
| 兼容性风险 | 无（因为库已和程序绑定）                                                                      | 有（著名的“DLL Hell”问题：版本冲突、库文件缺失）           |

#### 1. 静态链接库：“打包”进程序

编译库：将源代码编译成目标文件（.o），然后用 ar 工具打包成一个 .a 文件。这个文件本质上是一个压缩包，里面是很多 .o 文件的集合。

链接程序：当编译你的主程序时，链接器（Linker）会从静态库中提取它所需要的目标文件（.o），并将它们**直接复制**到最终的可执行文件中。

运行：最终生成的可执行文件**是自包含的**，不再需要原来的 .a 文件。

比喻： 就像你写一份报告，直接把需要的书籍的整章内容复印下来，订在自己的报告后面。交报告时，你不需要再带上那本书。

优缺点：

优点：部署简单；性能略好；无运行时依赖问题。

缺点：可执行文件体积大；浪费内存（无法共享）；库更新需重新编译整个程序。

#### 选择静态链接的场景：
- 简化部署：当你希望分发一个简单的、开箱即用的程序，不希望用户操心安装依赖库。例如，一个打包好的独立游戏或一个简单的工具程序。

- 性能极致优化：对启动速度和运行时性能有极致要求，希望避免动态链接的微小开销。

- 环境兼容性：你使用的库版本非常特殊，与目标系统上可能存在的版本不兼容，为了避免冲突，干脆静态链接。

- 嵌入式系统：目标系统资源有限，可能根本没有动态链接器，或者为了减少根文件系统的体积。

```bash
# 编译主程序并静态链接 libmylib.a
gcc -o myprogram main.c -L. -lmylib -static
```

#### 2. 动态链接库：“运行时借用”

编译库：使用编译器标志（如 -fPIC -shared）将代码编译成位置无关代码（PIC），并生成一个 .so 文件。这个文件是一个独立的可被加载的模块。

链接程序：编译主程序时，链接器**不会**将库代码复制进来，而是只记录一条信息：“我这个程序需要用到 libxxx.so 中的 foo 和 bar 这两个函数”。

运行：

- 操作系统加载你的可执行文件。

- 检查到它依赖 libxxx.so，于是去系统的标准路径（如 /usr/lib）或程序指定路径查找并加载这个库到内存。

- 一个叫做动态链接器的程序，将你的程序中对 foo 函数的调用，绑定到内存中 libxxx.so 里的 foo 函数的实际地址上。

此后，程序才能开始正常运行。

比喻： 就像你写报告时，只在脚注里写上“请参考《XX书籍》第Y章”。交报告时，你必须确保审阅人（操作系统）手边有这本书（动态库）。

优缺点：

优点：节省磁盘和内存（共享）；更新库无需重新编译主程序；便于模块化开发。

缺点：部署复杂，容易因库缺失或版本错误导致程序无法运行（“DLL Hell”）。

#### 选择动态链接的场景：
- 系统级库：像 libc.so（C标准库）和 libpthread.so（线程库）这样的基础库，几乎每个程序都要用。如果静态链接，每个程序都会有一份副本，极度浪费磁盘和内存。动态链接则让所有程序共享一份。

- 大型应用/模块化设计：像 Photoshop、Firefox 这样的软件，功能以插件（本质上是动态库）形式存在，可以动态加载和卸载，非常灵活。

- 库的频繁更新：如果你的库需要经常修复bug或更新功能，动态链接意味着你只需要分发一个新的 .so 文件，所有使用它的程序在下次启动时就会自动使用新版本。

- 节省空间：在服务器或桌面环境中，这是默认选择，可以显著节省总体空间。
```bash
# 编译主程序并动态链接 libmylib.so
gcc -o myprogram main.c -L. -lmylib

# 运行前可能需要告诉系统去哪里找这个 .so 库（如果不在标准路径）
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
./myprogram
```


## 2. 内存映射的工作原理

### （1）基本流程
- 映射建立：进程调用mmap()（Linux/Unix）或CreateFileMapping()（Windows），操作系统在虚拟地址空间分配一段内存区域。
- **文件关联**：将该区域与磁盘文件关联，但此时**并未实际加载数据**。
- **按需加载**：当进程访问该内存时，触发**缺页中断**，操作系统从磁盘读取对应数据到物理内存。
- **修改回写**：如果内存被修改，操作系统会在适当时候（如==msync()==或页面回收时）将数据写回磁盘。
### （2）关键系统调用（Linux）
```c++
#include <sys/mman.h>

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

int munmap(void *addr, size_t length);

int msync(void *addr, size_t length, int flags); // 同步内存和文件
```
**参数说明**：
- addr：建议映射的起始地址（通常设为==NULL==，由内核决定）。
- length：映射区域长度。
- prot：保护模式（如PROT_READ | PROT_WRITE）。
- flags：映射类型（MAP_SHARED或MAP_PRIVATE）。
- fd：文件描述符。
- offset：文件偏移量。

### 3. 内存映射的类型

**（1）私有映射（**==MAP_PRIVATE==**）**
- 修改仅对当前进程可见，不会写回文件（写时复制机制，Copy-on-Write）。
- **典型用途**：加载动态库、进程间隔离的数据修改。

**（2）共享映射（**==MAP_SHARED==**）**
- 修改对所有映射该文件的进程可见，并最终写回磁盘。
- **典型用途**：进程间通信（IPC）、数据库文件操作。

**（3）匿名映射（Anonymous Mapping）**
- 不关联任何文件，用于分配动态内存（类似==malloc==，但更灵活）。
- **示例**：
```c++
  void *mem = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
```
### 4. 内存映射 vs 传统文件 I/O
| **特性**         | 内存映射（mmap）         | 传统 I/O（read/write）       |
| ---------------- | ------------------------ | ---------------------------- |
| **数据拷贝**     | 零拷贝（直接访问页缓存） | 需从内核缓冲区拷贝到用户空间 |
| **系统调用开销** | 仅初始映射和缺页中断     | 每次==read/write==均需切换   |
| **大文件处理**   | 高效（按需加载）         | 需手动分块读写               |
| **随机访问**     | 支持指针直接跳转         | 需==lseek==调整文件偏移      |
| **适用场景**     | 高频随机访问、共享内存   | 简单顺序读写                 |

## 为什么虚拟内存空间可以大于物理内存？

虚拟内存（Virtual Memory）是现代操作系统的核心机制之一，它**允许进程使用比实际物理内存（RAM）更大的地址空间**。这种能力的实现依赖于以下关键技术：

### 1. 分页（Paging）和按需加载（Demand Paging）

**（1）虚拟内存与物理内存的解耦**
- **虚拟地址空间**：每个进程看到的是一个连续的、独立的地址范围（如 32 位系统是 4GB，64 位系统更大）。
- **物理内存**：实际可用的 RAM 可能远小于虚拟地址空间（如只有 8GB RAM）。
操作系统通过**页表（Page Table）**将虚拟地址映射到物理地址，但**并非所有虚拟页都需要立即分配物理内存**。

**（2）按需加载（Demand Paging）**
- **初始状态**：当进程申请内存（如malloc或mmap）时，操作系统仅分配虚拟地址，**不立即占用物理内存**。
- **实际访问时触发缺页中断（Page Fault）**：
- 当进程首次访问某块虚拟内存时，CPU 发现页表中无对应物理页 → 触发缺页中断。
- 操作系统介入，分配物理页并建立映射（可能需要从磁盘加载数据，如交换空间或文件）。
- **懒加载（Lazy Allocation）**：只有真正被使用的内存才会占用物理资源。

**示例**：
一个进程申请 1GB 虚拟内存，但实际只写了 100MB，那么只有 100MB 会占用物理内存。

### 2. 交换空间（Swap Space）

**（1）磁盘作为扩展内存**
- 当物理内存不足时，操作系统会将**不活跃的页面**换出（Swap Out）到磁盘的交换分区（Swap Partition）或交换文件（Swap File）。
- 当进程再次访问这些页面时，再换入（Swap In）到物理内存。
  
**（2）虚拟内存 \> 物理内存 + 交换空间？**
- 理论上，虚拟内存上限由 CPU 架构决定（如 64 位系统的 2^64 字节），但实际受限于：
- 操作系统配置（如 Linux 的==vm.overcommit_memory==）。
- 磁盘空间（交换分区大小）。
- 如果虚拟内存总和（所有进程）远超物理内存 + 交换空间，系统会因频繁换页而变慢（**抖动，Thrashing**）。
  
**3. 内存映射文件（Memory-Mapped Files）**
- 文件（如程序代码、数据文件）可以直接映射到虚拟地址空间。
- 访问文件时，操作系统按需加载部分内容到物理内存。

**优势**：
- 大文件（如 10GB）可以映射到虚拟内存，但仅加载实际访问的部分到物理内存。
- 避免一次性读取整个文件。

**4. 稀疏地址空间（Sparse Address Space）**
- 进程的虚拟地址空间可以存在“空洞”（未分配的区域），这些区域不占用物理内存。
- **示例**：
char \*p = malloc(1GB); // 仅分配虚拟地址剩余的 1GB - 4KB 仍为虚拟地址，但无物理内存占用。

**5. 过度提交（Overcommit）**
- Linux 等系统允许**承诺的虚拟内存 \> 物理内存 + 交换空间**（通过vm.overcommit_memory配置）。
- **风险**：如果所有进程同时尝试使用承诺的内存，可能导致 OOM（Out-of-Memory） Killer 终止进程。

**总结：为什么虚拟内存可以比物理内存大？**
| **技术**           | **作用**                                         |
| ------------------ | ------------------------------------------------ |
| **分页与按需加载** | 只有被访问的虚拟页才会占用物理内存。             |
| **交换空间**       | 磁盘作为物理内存的扩展，允许临时换出闲置数据。   |
| **内存映射文件**   | 文件内容按需加载，不一次性占用物理内存。         |
| **稀疏地址空间**   | 虚拟地址可以存在未分配的空洞，不消耗物理资源。   |
| **过度提交**       | 操作系统允许“超额承诺”虚拟内存（但需谨慎使用）。 |

