---
title: 内存映射
updated: 2025-08-22T18:43:13
created: 2025-04-15T11:05:31
---

mmap系统调用可以分配一段匿名的虚拟内存区域，也可以映射一个文件到内存，这个映射让文件操作像直接操作内存一样，这种方式称之为**内存映射**。

**mmap()必须以内存页（PAGE_SIZE）为单位进行映射**，而内存也只能以页为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先**进行内存对齐**，强行以PAGE_SIZE的倍数大小进行映射。

mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。在要求高性能的应用中比较常用，但在面向流的设备不能进行mmap，mmap的实现和硬件有关。

## 内存映射（Memory Mapping）详解

内存映射（Memory Mapping）是**一种将文件或设备直接映射到进程地址空间的技术**，使得程序可以像访问内存一样读写文件或硬件资源，而不需要传统的read()/write()系统调用。它广泛应用于文件 I/O 优化、进程间通信（IPC）、动态库加载等领域。

**1. 内存映射的基本概念**

**（1）什么是内存映射？**
- 定义：将文件或设备的一部分映射到进程的虚拟内存空间，使得程序可以直接通过指针访问文件内容，而无需显式调用read()/write()。
- **核心机制**：由操作系统管理，底层使用**页表**（Page Table）和<b>缺页中断（Page Fault）</b>实现按需加载。

**（2）主要用途**
- **高效文件 I/O**：减少用户态和内核态之间的数据拷贝（零拷贝技术）。
- **共享内存 IPC**：多个进程映射同一文件，实现高效数据共享。
- **动态库加载**：==.so==/==.dll==文件通过内存映射加载到进程空间。
- **大数据处理**：处理超大文件时，避免一次性加载整个文件。
## 2. 内存映射的工作原理

### （1）基本流程
- 映射建立：进程调用mmap()（Linux/Unix）或CreateFileMapping()（Windows），操作系统在虚拟地址空间分配一段内存区域。
- **文件关联**：将该区域与磁盘文件关联，但此时**并未实际加载数据**。
- **按需加载**：当进程访问该内存时，触发**缺页中断**，操作系统从磁盘读取对应数据到物理内存。
- **修改回写**：如果内存被修改，操作系统会在适当时候（如==msync()==或页面回收时）将数据写回磁盘。
### （2）关键系统调用（Linux）
```c++
#include <sys/mman.h>

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

int munmap(void *addr, size_t length);

int msync(void *addr, size_t length, int flags); // 同步内存和文件
```
**参数说明**：
- addr：建议映射的起始地址（通常设为==NULL==，由内核决定）。
- length：映射区域长度。
- prot：保护模式（如PROT_READ | PROT_WRITE）。
- flags：映射类型（MAP_SHARED或MAP_PRIVATE）。
- fd：文件描述符。
- offset：文件偏移量。

### 3. 内存映射的类型

**（1）私有映射（**==MAP_PRIVATE==**）**
- 修改仅对当前进程可见，不会写回文件（写时复制机制，Copy-on-Write）。
- **典型用途**：加载动态库、进程间隔离的数据修改。

**（2）共享映射（**==MAP_SHARED==**）**
- 修改对所有映射该文件的进程可见，并最终写回磁盘。
- **典型用途**：进程间通信（IPC）、数据库文件操作。

**（3）匿名映射（Anonymous Mapping）**
- 不关联任何文件，用于分配动态内存（类似==malloc==，但更灵活）。
- **示例**：
```c++
  void *mem = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
```
### 4. 内存映射 vs 传统文件 I/O
| **特性** | 内存映射（mmap） | 传统 I/O（read/write） |
|----|----|----|
| **数据拷贝** | 零拷贝（直接访问页缓存） | 需从内核缓冲区拷贝到用户空间 |
| **系统调用开销** | 仅初始映射和缺页中断 | 每次==read/write==均需切换 |
| **大文件处理** | 高效（按需加载） | 需手动分块读写 |
| **随机访问** | 支持指针直接跳转 | 需==lseek==调整文件偏移 |
| **适用场景** | 高频随机访问、共享内存 | 简单顺序读写 |

## 为什么虚拟内存空间可以大于物理内存？

虚拟内存（Virtual Memory）是现代操作系统的核心机制之一，它**允许进程使用比实际物理内存（RAM）更大的地址空间**。这种能力的实现依赖于以下关键技术：

### 1. 分页（Paging）和按需加载（Demand Paging）

**（1）虚拟内存与物理内存的解耦**
- **虚拟地址空间**：每个进程看到的是一个连续的、独立的地址范围（如 32 位系统是 4GB，64 位系统更大）。
- **物理内存**：实际可用的 RAM 可能远小于虚拟地址空间（如只有 8GB RAM）。
操作系统通过**页表（Page Table）**将虚拟地址映射到物理地址，但**并非所有虚拟页都需要立即分配物理内存**。

**（2）按需加载（Demand Paging）**
- **初始状态**：当进程申请内存（如malloc或mmap）时，操作系统仅分配虚拟地址，**不立即占用物理内存**。
- **实际访问时触发缺页中断（Page Fault）**：
- 当进程首次访问某块虚拟内存时，CPU 发现页表中无对应物理页 → 触发缺页中断。
- 操作系统介入，分配物理页并建立映射（可能需要从磁盘加载数据，如交换空间或文件）。
- **懒加载（Lazy Allocation）**：只有真正被使用的内存才会占用物理资源。

**示例**：
一个进程申请 1GB 虚拟内存，但实际只写了 100MB，那么只有 100MB 会占用物理内存。

### 2. 交换空间（Swap Space）

**（1）磁盘作为扩展内存**
- 当物理内存不足时，操作系统会将**不活跃的页面**换出（Swap Out）到磁盘的交换分区（Swap Partition）或交换文件（Swap File）。
- 当进程再次访问这些页面时，再换入（Swap In）到物理内存。
  
**（2）虚拟内存 \> 物理内存 + 交换空间？**
- 理论上，虚拟内存上限由 CPU 架构决定（如 64 位系统的 2^64 字节），但实际受限于：
- 操作系统配置（如 Linux 的==vm.overcommit_memory==）。
- 磁盘空间（交换分区大小）。
- 如果虚拟内存总和（所有进程）远超物理内存 + 交换空间，系统会因频繁换页而变慢（**抖动，Thrashing**）。
  
**3. 内存映射文件（Memory-Mapped Files）**
- 文件（如程序代码、数据文件）可以直接映射到虚拟地址空间。
- 访问文件时，操作系统按需加载部分内容到物理内存。

**优势**：
- 大文件（如 10GB）可以映射到虚拟内存，但仅加载实际访问的部分到物理内存。
- 避免一次性读取整个文件。

**4. 稀疏地址空间（Sparse Address Space）**
- 进程的虚拟地址空间可以存在“空洞”（未分配的区域），这些区域不占用物理内存。
- **示例**：
char \*p = malloc(1GB); // 仅分配虚拟地址剩余的 1GB - 4KB 仍为虚拟地址，但无物理内存占用。

**5. 过度提交（Overcommit）**
- Linux 等系统允许**承诺的虚拟内存 \> 物理内存 + 交换空间**（通过vm.overcommit_memory配置）。
- **风险**：如果所有进程同时尝试使用承诺的内存，可能导致 OOM（Out-of-Memory） Killer 终止进程。

**总结：为什么虚拟内存可以比物理内存大？**
| **技术**           | **作用**                                         |
|--------------------|--------------------------------------------------|
| **分页与按需加载** | 只有被访问的虚拟页才会占用物理内存。             |
| **交换空间**       | 磁盘作为物理内存的扩展，允许临时换出闲置数据。   |
| **内存映射文件**   | 文件内容按需加载，不一次性占用物理内存。         |
| **稀疏地址空间**   | 虚拟地址可以存在未分配的空洞，不消耗物理资源。   |
| **过度提交**       | 操作系统允许“超额承诺”虚拟内存（但需谨慎使用）。 |

