---
title: 内存泄漏
updated: 2025-04-15T16:08:16
created: 2025-04-15T16:07:32
---

## 内存泄露是什么？
简单来说就是：<strong style="color:red">在程序中申请了动态内存，却没有释放，如果程序长期运行下去，最终会导致没有内存可供分配。</strong><br>
所以不少大厂的服务有个特点，就是会定期重启服务进程，重启的目的就是让操作系统回收整个进程的资源包括内存，这样一点点的内存泄露问题即使无法定位，也不是什么大问题哈哈哈

### 类别一：数据结构与编程错误
#### 1. 容器中的对象指针
这是非常经典的场景。如果你在容器（如 std::vector, std::list, std::map）中存放了原始指针，那么在清空容器时，如果不手动遍历并 delete 每一个指针，就会导致泄漏。
```c++
std::vector<MyClass*> vec;
vec.push_back(new MyClass());
vec.push_back(new MyClass());

// ... 使用 vec

vec.clear(); // 漏洞！只是移除了指针，并没有 delete 指向的对象。
// 正确的做法：
// for (auto* ptr : vec) { delete ptr; }
// vec.clear();
```
现代C++解决方案：使用智能指针（std::unique_ptr, std::shared_ptr）代替原始指针。
```c++
std::vector<std::unique_ptr<MyClass>> vec;
vec.push_back(std::make_unique<MyClass>());
// 当 vec 被销毁或 clear 时，所有对象会自动被 delete。
```
#### 2. 循环引用（针对 std::shared_ptr）
这是智能指针特有的陷阱。当两个或多个对象使用 std::shared_ptr 互相引用时，会形成循环引用，导致引用计数永远无法降为零，从而无法释放内存。

#### 3. 静态对象持有资源
静态对象的析构函数可能在不恰当的时机被调用，或者因为析构顺序问题，导致其持有的资源无法被正确释放。

### 类别二：系统资源泄漏
内存泄漏不单指堆内存，还包括操作系统资源。这些资源本质上也是由内核分配的内存。

#### 1. 文件描述符泄漏
打开文件、网络套接字等后没有关闭。
#### 2. 内存映射区域未解除映射
使用 mmap 映射了文件到内存空间，但没有使用 munmap 解除映射。

#### 3. 线程资源泄漏
创建了线程（如 pthread_create）但没有将其合并（pthread_join）或分离（pthread_detach），导致线程资源无法被回收。

## 检测内存泄露的方法：
1.  手动检查代码：仔细检查代码中的内存分配和释放，确保每次分配内存后都有相应的释放操作。比如 malloc和free、new和delete是否配对使用了。
2.  使用调试器和工具：有一些工具可以帮助检测内存泄露。例如：
    - `Valgrind`（仅限于Linux和macOS）：Valgrind是一个功能强大的内存管理分析工具，可以检测内存泄露、未初始化的内存访问、数组越界等问题。使用Valgrind分析程序时，只需在命令行中输入```valgrind --leak-check=yes your_program```即可。
    - Visual Studio中的`CRT（C Runtime）`调试功能：Visual Studio提供了一些用于检测内存泄露的C Runtime库调试功能。例如，\_CrtDumpMemoryLeaks函数可以在程序结束时报告内存泄露。
    - `AddressSanitizer`：AddressSanitizer是一个用于检测内存错误的编译器插件，适用于GCC和Clang。要启用AddressSanitizer，只需在编译时添加```-fsanitize=address```选项。
### 如何避免内存泄露
1.  **使用智能指针（C++）**：在C++中，可以使用智能指针（如std::unique_ptr和std::shared_ptr）来自动管理内存。这些智能指针在作用域结束时会自动释放所指向的内存，从而降低忘记释放内存或者程序异常导致内存泄露的风险。
2.  异常安全：在C++中，如果程序抛出异常，需要确保在异常处理过程中正确释放已分配的内存。使用try-catch块来捕获异常并在适当的位置释放内存。 或者使用RAII（Resource Acquisition Is Initialization）技术（关于RAII可以看这篇文章:如何理解RAII，将资源（如内存）的管理与对象的生命周期绑定。
