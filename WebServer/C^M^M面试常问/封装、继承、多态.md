---
title: 封装、继承、多态
updated: 2025-08-22T16:12:05
created: 2025-04-15T10:33:46
---

### 封装
将**具体实现过程和数据封装成一个类**，只能通过接口进行访问，降低耦合性，使类成为一个具有内部数据的自我隐藏能力、功能独立的软件模块。<br>
**意义**：保护或防止代码在无意之中被破坏，保护类中的成员，不让类中以外的程序直接访问或者修改，只能通过提供的公共接口访问。

### 继承
子类继承父类的特征和行为，复用了基类的**全体数据**和**成员函数**，具有从基类复制而来的**数据成员**和**成员函数**（基类私有成员可被继承，但是无法被访问），**其中构造函数、析构函数、友元函数、静态数据成员、静态成员函数都不能被继承。**<br>
基类中成员的访问方式只能决定派生类能否访问它们。增强了代码耦合性，当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员函数不能重写或修改。<br>
**意义**：基类的程序代码可以被派生类复用，提高了软件复用的效率，缩短了软件开发的周期<br>
### 多态
**不同继承类的对象对同一消息做出不同的响应**，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。<br>
**意义**：对已存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应用代码的编写和修改过程。

### 2.多态的实现原理（实现方式）是什么？以及多态的优点（特点）？
**实现方式**：多态分为**动态多态**（动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。）和**静态多态**（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数）。
- **动态多态**是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做`虚函数表`，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。
- **静态多态则是通过函数重载**（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关，与参数没有关系.）来实现的。
  
**优点**：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。

### 重载和重写
#### 重载
函数名相同，但**参数的个数或类型不同**，编译器会根据参数推导调用哪个函数
| **特性**       | **描述**                                   |
|----------------|--------------------------------------------|
| 作用范围       | 同一类/命名空间                            |
| 参数要求       | 参数个数、类型或顺序不同                   |
| **返回值影响** | **不影响重载（仅靠返回值不同不构成重载）** |
| 发生时机       | 编译时（静态绑定）  

在编译阶段，**函数调用的匹配是基于“参数列表”，而不是返回类型**，返回值在函数调用之后才用得上，无法参与重载决策。
#### 重写
**子类中定义一个与父类中同名、参数完全相同的虚函数**，用于修改或扩展其行为
| **特性** | **描述** |
|----|----|
| 要求函数为虚函数 | 父类函数必须是 virtual（或在 C++11 起加 override 关键字） |
| 参数必须一致 | 名字、参数个数、类型、顺序都要一样 |
| 返回值类型一致（或协变） | C++ 允许返回值是子类指针/引用 |
| 发生时机 | 运行时（动态绑定） |


