---
title: 多线程的死锁
updated: 2025-08-22T19:00:22
created: 2025-04-15T11:25:06
---

因为在多进程中易发生多进程对资源进行竞争，如果一个进程集合里面的每一个进程都在等待这个集合中的其他一个进程才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁。**产生死锁的四个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件**。解决死锁的方法就是破坏上述任意一种条件。
![image1](../../../resources/5fa04206ab3d4320a8c5ef42dc03a307.jpg)
#### 1、互斥条件
互斥即非此即彼，一个资源要不是我拥有，要不是你拥有，就是不能我们俩同时拥有。也就是互斥条件是指**至少有一个资源处于非共享状态**，一次只能有一个线程可以访问该资源。

#### 2、占有并等待条件
该条件是指一个线程**在拥有至少一个资源的同时还在等待获取其他线程拥有的资源**。

#### 3、不可剥夺条件
该条件是指一个线程一旦获取了某个资源，则不可被强行剥夺对该资源的所有权，只能等待该线程自己主动释放。
#### 4、循环等待条件
循环等待是指线程等待资源形成的循环链，比如线程A等待资源B，线程B等待资源C，线程C等待资源A，但是资源A被线程A拥有，资源B被线程B拥有，资源C被线程C拥有，如此形成了依赖死循环，都在等待其他线程释放资源。

## 死锁的检查与定位

### 使用系统工具

Linux 下可以用 ```ps -Lf <pid>``` 查看某进程的线程状态；

```gdb attach <pid>``` 或 ```pstack <pid>``` 打印各线程的堆栈，看到互相 ```pthread_mutex_lock``` 卡住的位置；

```strace -p <pid>``` 观察系统调用卡在哪；

### C/C++ 项目可以用 Helgrind
（Valgrind 的子工具）或 Clang ThreadSanitizer 检查死锁和数据竞争。

### 在代码里加调试日志
每次加锁、解锁时打印线程 ID 和锁名，出现“线程 A 已加锁锁1，等待锁2；线程 B 已加锁锁2，等待锁1”就能看出死锁。

### 使用带超时的锁
```pthread_mutex_timedlock``` 或 C++17 的 std::timed_mutex 在超时时返回，可以用来检测是否有死锁迹象。

## 死锁的避免与解决

### 固定锁顺序
所有线程获取多把锁时必须按统一顺序（例如先锁 A 再锁 B），这样就不会形成循环等待。

### 减少锁的持有时间
把临界区缩到最小，拿到锁就做关键操作，马上释放。

### 拆分锁 / 粗细粒度调整
如果一把大锁包住很多不相关操作，可以拆成几把小锁，降低互相等待的概率。

### 使用更高级的同步原语
读写锁（pthread_rwlock）、原子操作（std::atomic）、无锁队列等，有时能替代互斥锁。