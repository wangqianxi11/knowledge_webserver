# Socket 
底层调用本质上是一系列与网络协议栈交互的系统调用。

我们可以把 Socket API 的调用过程看作一个分层模型，从应用程序的抽象调用，一直到内核与网卡驱动的交互。

核心系统调用概览
一个典型的 TCP Socket 通信流程所涉及的核心系统调用如下表所示：

|步骤	|服务端调用|	客户端调用	|目的|
|--------|-------|---------|--------|
|1. 创建	|socket()	|socket()	|创建一个通信端点，返回文件描述符。
|2. 绑定	|bind()	|(可选)	|将 Socket 与一个本地 IP 地址和端口号绑定。
|3. 监听	|listen()	|-	|将 Socket 置于被动监听模式，准备接受连接。
|4. 连接	|-	|connect()|	客户端主动向服务端发起连接请求。
|5. 接受	|accept()|	-	|服务端从已完成连接队列中接受一个连接，返回新 Socket。
|6. 数据传输|	send()/write()	|send()/write()	|发送数据。|
||recv()/read()|	recv()/read()|	接收数据。
|7. 关闭	|close()|	close()	|关闭 Socket，释放资源。

## 1. socket() - 创建通信端点
```c++
int socket(int domain, int type, int protocol);
// 示例: int sockfd = socket(AF_INET, SOCK_STREAM, 0);
```
底层做了什么：

- 内核在进程的打开文件描述符表中分配一个新的条目。

- 在内核中创建一个 `struct socket` 结构体，这个结构体包含了该 `Socket` 的所有状态信息（类型、状态、读写缓冲区等）。

- 将其与一个虚拟文件关联起来。这就是为什么 `Socket` 的操作（读、写、关闭）和文件操作如此相似的原因——在 `Unix/Linux` 中，“一切皆文件”。

- 返回一个文件描述符，后续所有操作都通过这个描述符进行。

## 2. bind() - 绑定地址
```
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
底层做了什么：

- 内核将应用程序指定的 IP 地址和端口号赋值给之前创建的 struct socket 结构体。

- 对于服务端，这通常是将其绑定到一个众所周知的端口（如 80 for HTTP）。

- 对于客户端，通常可以省略，内核会自动分配一个临时端口（Ephemeral Port）。

## 3. listen() - 开启监听
```
int listen(int sockfd, int backlog);
```
底层做了什么：

- 内核将 Socket 的状态从 `SS_UNCONNECTED` 改为 `SS_LISTEN`，标记其为监听 Socket。

- 内核创建两个队列：

  - 半连接队列（SYN Queue）：存放已完成 SYN-SYN-ACK 握手，但尚未完成三次握手的连接。

  - 全连接队列（Accept Queue）：存放已完成三次握手，等待应用程序调用 accept() 取走的连接。

- `backlog` 参数历史上用于定义这两个队列的总长度上限，但在不同系统中有不同解释。

## 4. connect() - 发起连接
```
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
底层做了什么：

- 客户端内核选择一个临时端口，并发送一个 SYN 包到服务端指定的地址和端口。

- 将 Socket 状态改为 SYN_SENT。

- 阻塞等待服务端的 SYN-ACK 包。

- 收到 SYN-ACK 后，回复 ACK，完成三次握手。

- 将 Socket 状态改为 `ESTABLISHED`。

- connect() 系统调用返回。

整个过程由内核协议栈自动完成，对应用程序透明。

## 5. accept() - 接受连接
```
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
底层做了什么：

- 内核从全连接队列中取出第一个已建立的连接。

- 如果队列为空，并且 Socket 是阻塞的，则进程会睡眠，直到有新连接到来。

- 内核创建一个全新的 Socket，并返回其文件描述符。这个新 Socket 用于与刚刚接受的客户端进行通信。

关键的理解：listenfd（监听 Socket）只负责接受连接，而 acceptfd（接受返回的新 Socket）负责与特定客户端通信。一个服务端只有一个 listenfd，但可以同时有成千上万个 acceptfd。

## 6. send() / recv() - 数据传输
这些调用本质上是对 write() 和 read() 系统调用的包装。

### send() 底层流程：

- 应用程序将数据从用户态缓冲区传入内核。

- 数据被拷贝到 Socket 的发送缓冲区。

- send() 系统调用立即返回，它只表示数据已成功进入发送缓冲区，并不表示对端已收到。

内核协议栈在后台负责将发送缓冲区的数据打包成 TCP 段，加上 IP 头、TCP 头，通过网卡发送出去。这个过程受拥塞控制和流量控制算法影响。

### recv() 底层流程：

内核从网卡收到数据包，经过协议栈解析，将有效载荷数据放入 Socket 的接收缓冲区。

应用程序调用 recv()，数据从内核的接收缓冲区拷贝到用户态的缓冲区。

如果接收缓冲区为空，默认情况下 recv() 会阻塞，直到有数据到来。

核心要点：用户态和内核态之间的数据拷贝是必须的，这也是高性能网络编程中需要优化的关键点之一。

## 7. close() - 关闭连接
```
int close(int fd);
```
底层做了什么：

- 如果这是对某个 Socket 的最后一次引用（引用计数为0）：

对于 TCP，内核会发起 四次挥手 来优雅地关闭连接（发送 FIN 包）。

释放该 Socket 占用的所有内核资源（发送缓冲区、接收缓冲区、struct socket 本身等）。

释放文件描述符。


# TCP 状态机概述
TCP 状态机是描述 TCP 连接从开始到结束所有可能状态的模型。以下是完整的状态列表，我们按照连接的建立、传输和终止三个阶段来分组讲解。

## 1. 连接建立阶段的状态
### LISTEN
含义：服务端特有的状态。表示 Socket 正在监听指定的端口，等待客户端的连接请求。

触发：服务端成功调用 socket(), bind(), listen() 之后。

在 netstat 中看到：说明该 Socket 是一个服务端监听 Socket。

### SYN_SENT
含义：客户端特有的状态。表示客户端已经发送了连接请求（SYN 包），正在等待服务端的确认（SYN-ACK 包）。

触发：客户端调用 connect() 之后。

生命周期：通常非常短暂。如果长时间停留在此状态，可能表示 SYN 包丢失或防火墙阻止。

### SYN_RECEIVED (或 SYN_RCVD)
含义：服务端特有的状态。表示服务端已经收到客户端的 SYN 包，并发送了自己的 SYN-ACK 包作为回应，现在正在等待客户端的最终 ACK 包。

触发：服务端收到 SYN 包并发出 SYN-ACK 之后。

生命周期：非常短暂，是三次握手的中间状态。

### ESTABLISHED
含义：连接已就绪。表示三次握手已经完成，TCP 连接已经建立成功。此时双方可以自由地发送和接收数据。

触发：

客户端：收到服务端的 SYN-ACK 并发出 ACK 之后。

服务端：收到客户端的 ACK 之后（对于 accept() 返回的新 Socket）。

在 netstat 中看到：这是正常数据传输时最常见的状态。

## 2. 连接终止阶段的状态
TCP 断开连接需要四次挥手，因此产生了更多的状态。

### FIN_WAIT_1
含义：主动关闭方（先调用 close() 的一方）的状态。表示该方已经发送了 FIN 包，请求终止连接，正在等待对方的 ACK 确认。

触发：应用程序调用 close() 后。

### FIN_WAIT_2
含义：主动关闭方的状态。表示已经收到了对方对 FIN 包的 ACK 确认，现在正在等待对方也发送它的 FIN 包。

触发：在 FIN_WAIT_1 状态下收到 ACK 后进入。

### CLOSE_WAIT
含义：被动关闭方（收到 FIN 包的一方）的状态。表示已经收到了对方的 FIN 包，并进行了 ACK 确认。此时连接处于半关闭状态，本方还可以继续发送数据，但不会再收到数据。

触发：收到对方的 FIN 包。

问题指示：如果系统中存在大量 CLOSE_WAIT 状态的连接，通常意味着你的应用程序在收到 FIN 包后没有及时调用 close() 来关闭自己这一侧的连接。

### LAST_ACK
含义：被动关闭方的状态。表示被动关闭方已经发送了自己的 FIN 包，正在等待对方最后的 ACK 确认。

触发：被动关闭方在 CLOSE_WAIT 状态下，也调用 close() 发送 FIN 包之后。

### TIME_WAIT (或 CLOSING)
含义：主动关闭方的最终状态。在收到被动关闭方的 FIN 包并发出最后的 ACK 之后，连接会进入 TIME_WAIT 状态。

目的：

可靠的终止：确保最后的 ACK 能到达对方。如果 ACK 丢失，对方会重传 FIN，此时处于 TIME_WAIT 的 Socket 可以再次回复 ACK。

清除旧包：让所有在网络中延迟的、属于这个连接的数据包都过期失效，避免被之后新的、复用了相同四元组（源IP、源端口、目的IP、目的端口）的连接错误地接收。

持续时间：通常是 2 * MSL（Maximum Segment Lifetime，报文最大生存时间），在 Linux 上一般是 60 秒。

在 netstat 中看到：在高性能服务器上，主动关闭连接后会出现大量 TIME_WAIT 连接，这是正常现象。

### CLOSED
含义：连接的最终状态。表示连接已经完全关闭，所有资源都已释放。

