---
title: malloc和new
updated: 2025-08-22T18:37:24
created: 2025-04-15T11:02:08
---

# new和malloc两者的区别
## 属性的区别
new/delete：这两个是C++中的关键字，若要使用，需要编译器支持；
malloc/free：这两个是库函数，若要使用则需要引入相应的头文件才可以正常使用。
## 使用上的区别
malloc：申请空间需要显式填入申请内存的大小；
new：无需显式填入申请的内存大小，new会根据new的类型分配内存。
实例：
```c++
/** malloc/free用例 **/

int*ma = (int*)malloc(4)；

free(ma)；

/** new/delete用例 **/

int*ne =new int(0);
```
## 内存位置的区别
new：此操作符分配的内存空间是在`自由存储区`；

malloc：申请的内存是在`堆空间`。

C/C++的内存通常分为：**堆、栈、自由存储区、全局/静态存储区、常量存储区**。可能除了自由存储区，其他的内存分布大家应该都比较熟悉。

**堆**是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，调用free()归还内存。

**自由存储区**是C++中动态分配和释放对象的一个概念，通过new分配的内存区域可以称为自由存储区，通过delete释放归还内存。

**自由存储区可以是堆、全局/静态存储区等，具体是在哪个区，主要还是要看new的实现以及C++编译器默认new申请的内存是在哪里**。但是基本上，很多C++编译器默认使用堆来实现自由存储，运算符new和delete内部默认是使用malloc和free的方式来被实现，说它在堆上也对，说它在自由存储区上也正确。因为在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等。而malloc和free是C里的库函数，无法对其进行重载。
## 返回类型的区别
- new操作符内存分配成功时，**返回的是对象类型的指针**，类型严格与对象匹配，无须进行类型转换，故new是符合`类型安全性`的操作符。
- malloc内存分配成功则是返回void \* ，需要通过强制类型转换将void\*指针转换成我们需要的类型。所以在C++程序中使用new会比malloc安全可靠。
## 分配失败情况的区别
- malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是否分配成功；
- new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL，分配失败时如果不捕捉异常，那么程序就会异常退出，我们可以通过`异常捕捉`的方式获取该异常。
## 定义对象系统调度过程的区别
使用new操作符来分配对象内存时会经历三个步骤：
- 调用operator new 函数（对于数组是operator new\[\]）分配一块足够的内存空间（通常底层默认使用malloc实现，除非程序员重载new符号）以便存储特定类型的对象；
- 编译器运行相应的构造函数以构造对象，并为其传入初值。
- 对象构造完成后，返回一个指向该对象的指针。
使用delete操作符来释放对象内存时会经历两个步骤：
- 调用对象的析构函数。
- 编译器调用operator delete(或operator delete\[\])函数释放内存空间（通常底层默认使用free实现，除非程序员重载delete符号）。

## 扩张内存大小的区别
- malloc：使用malloc分配内存后，发现内存不够用，那我们可以通过`realloc`函数来扩张内存大小，realloc会先判断当前申请的内存后面是否还有足够的内存空间进行扩张，如果有足够的空间，那么就会往后面继续申请空间，并返回原来的地址指针；否则realloc会在另外有足够大小的内存申请一块空间，并将当前内存空间里的内容拷贝到新的内存空间里，最后返回新的地址指针。
- new：**new没有扩张内存的机制。**

| 特征 | new/delete | malloc/free |
|----|----|----|
| 分配内存的位置 | 自由存储区 | 堆 |
| 内存分配成功的返回值 | 完整类型指针 | void\* |
| 内存分配失败的返回值 | 默认抛出异常 | 返回NULL |
| 分配内存的大小 | 由编译器根据类型计算得出 | 必须显式指定字节数 |
| 处理数组 | 有处理数组的new版本new\[\] | 需要用户计算数组的大小后进行内存分配 |
| 已分配内存的扩充 | 无法直观地处理 | 使用realloc简单完成 |
| 是否相互调用 | 可以，看具体的operator new/delete实现 | 不可调用new |
| 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器 | 无法通过用户代码进行处理 |
| 函数重载 | 允许 | 不允许 |
| 构造函数与析构函数 | 调用 | 不调用 |


## realloc和malloc的区别
### 核心区别对比表
|特性	|malloc()|	realloc()|
|----------|-------------|-------------|
|全称|	Memory Allocation|	Memory Re-Allocation
|目的|	**分配一块新的内存块**|	**调整一块已存在的内存块的大小**
|参数|	`size_t size` (所需字节数)|	`void *ptr` (原内存指针), `size_t size` (新字节数)
|返回值|	成功：指向新内存的指针；失败：NULL	成功：指向新内存的指针；|失败：NULL，且原内存块不变
|原内存内容|	新内存的内容是未初始化的（是垃圾值）|	尝试保留原内存块的内容（直到新旧大小的最小值）
|原指针	|不涉及其他指针	|传入的原指针 `ptr` 会失效，必须使用 `realloc()` 返回的新指针

### malloc() - 分配新内存
**功能**：向系统申请分配指定字节数的连续内存空间。
```c++
#include <stdlib.h>
void *malloc(size_t size);
```

### realloc() - 调整已存在内存的大小
**功能**：用于扩大或缩小之前动态分配的内存块。
```c++
#include <stdlib.h>
void *realloc(void *ptr, size_t size);
```

参数：

- `ptr`：必须是之前由 `malloc()`, `calloc()`, 或 `realloc()` 返回的指针。如果 ptr 是 NULL，则 realloc() 的行为完全等同于 `malloc(size)`。

- `size`：内存块的新大小。如果为 0，且 `ptr` 非空，则行为等同于 `free(ptr)`，并返回 NULL。

realloc() 的内部行为（非常重要）：
当你调用 realloc(ptr, new_size) 时，它会尝试完成以下步骤：

- **检查原地扩展**：首先检查 `ptr` 指向的内存块后面是否有足够的空闲空间来直接扩大分配。如果有，它就直接在原地扩大内存块，并返回传入的原指针 `ptr`。这是最高效的情况。

- **寻找新空间**：如果原地没有足够空间，它会：
    - 在别处分配一块新的、更大的内存块。

    - 将旧内存块中的数据自动复制到新的内存块中（复制长度是 min(old_size, new_size)）。

    - 自动释放旧的内存块。

    - 返回一个指向新内存块的指针。

- **分配失败**：如果新的内存分配失败（例如内存不足），它会返回 NULL，但传入的旧内存块 ptr 仍然有效，你需要负责后续的释放。
```c++
int *arr = (int*)malloc(5 * sizeof(int));
// ... 初始化并使用这 5 个元素 ...

// 现在需要扩大到 10 个元素
int *new_arr = (int*)realloc(arr, 10 * sizeof(int)); // 关键：使用临时指针接收返回值

if (new_arr == NULL) {
    // 扩容失败！但原数组依然存在，可以用，只是大小没变
    fprintf(stderr, "Failed to expand memory!\n");
    // 注意：此时 arr 仍然是有效的，不能 free(arr) 然后退出，而是应该降级处理
    // 例如：继续使用大小为5的数组，或者执行其他清理操作
} else {
    // 扩容成功！让原指针指向新的内存块
    arr = new_arr; // 现在 arr 指向新的、更大的内存块
    // 旧指针已由 realloc 自动释放，不能再使用或手动 free 旧值
}

// 继续使用 arr (现在大小为10)
// ... ...
free(arr); // 最终只需释放一次
```
错误的使用方法：
```c++
arr = (int*)realloc(arr, 10 * sizeof(int)); // 错误！如果返回NULL，原内存地址就丢失了，导致内存泄漏
```

### 核心要点：

1.`malloc` 用于初次分配，`realloc` 用于后续调整。

2.永远不要 `ptr = realloc(ptr, new_size)`。如果 `realloc` 失败返回 NULL，你会不仅无法获得新内存，还会丢失原来内存块的指针，造成无法释放的内存泄漏。

3.`realloc` 是一个可能“搬家”的操作。扩容后，原来的指针会失效，必须使用 `realloc` 返回的新指针。任何保存旧指针副本的地方都需要更新。

4.`realloc` 可以用来分配内存：`realloc(NULL, size) ≡ malloc(size)`。

5.`realloc` 可以用来释放内存：`realloc(ptr, 0) ≡ free(ptr)`（并返回 NULL），但这种用法不常见，不如直接调用 free() 清晰。
