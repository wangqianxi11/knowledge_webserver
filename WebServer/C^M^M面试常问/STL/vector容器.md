---
title: vector容器
updated: 2025-05-08T11:28:17
created: 2025-04-15T14:49:58
---

**优点：**可使用下标随机访问，尾插尾删效率高。
**缺点**：前面部分的插入删除效率低，扩容有消耗，可能存在一定的空间浪费。
**底层**是由一块连续的内存空间组成，由三个指针实现的分别是头指针（表示目前使用空间的头），尾指针（表示目前使用空间的尾）和可用空间尾指针实现，双向链表实现

底层是**动态数组**
#### 什么是动态数组？
| **特性**           | **描述**                                   |
|--------------------|--------------------------------------------|
| ✅ 动态扩容        | 可以根据元素数量动态申请或释放内存         |
| ✅ 顺序访问        | 支持索引操作 arr\[i\]，时间复杂度为 O(1)   |
| ✅ 连续内存存储    | 内部数据依旧是连续分布的，就像普通数组一样 |
| ❌ 插入/删除代价高 | 除尾部外，其它位置插入/删除需要移动元素    |
|                   |                                           |
## vector中的push_back()和emplace_back()的区别、以及使用场景
当使用Push_back时会先调用类的有参构造函数创建一个临时变量，再将这个元素拷贝或者移动到容器之中，而emplace_back则是直接在容器尾部进行构造比push_back少进行一次构造函数调用。
在大部分场景中emplace_back可以替换push_back，但是push_back会比emplace_back更加安全，emplace_back只能用于直接在容器中构造新元素的情况，如果要将现有的对象添加到容器中则需要使用push_back

## vector扩容，resize和reserve的区别
使用resize改变的是vector的大小（size），可能会添加或删除元素。
使用reserve改变的是vector的容量（capacity），不会改变当前元素的数量，仅仅是为了优化内存使用和性能。

## vector扩容为了避免重复扩容做了哪些机制？
当vector内存不够时本身内存会以1.5或者2倍的增长，以减少扩容次数
引入了reserve，自定义vector最大容量

