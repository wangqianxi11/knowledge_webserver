---
title: 拷贝构造函数
updated: 2025-08-22T19:14:15
created: 2025-05-10T09:39:48
---

### 拷贝构造函数：创建对象时，使用同一类中之前创建的对象来初始化新创建的对象
- 通过使用另一个同类型的对象来初始化新创建的对象
- 复制对象把它作为参数传递给函数
- 复制对象，并从函数返回对象

**注意**: 同样不能是虚函数

**如果类中没有定义，编译器会自行定义。如果类带有指针变量，并有动态内存分配，则必须有拷贝构造函数**
#### 特点：
1.  函数名与类名相同。
2.  参数：必须是对本类类型的一个引用，几乎总是常量引用<strong> (const MyClass&) </strong>。
- 为什么是引用？如果不是引用，在传参时就需要调用拷贝构造函数自身来创建形参，这将导致无限递归调用，编译器会报错。
- 为什么是const？因为创建副本通常不应该修改源对象。
```c++
MyClass obj1; // 调用普通构造函数

MyClass obj2(obj1); // 显式调用：调用拷贝构造函数 MyClass::MyClass(const MyClass&)

MyClass obj3 = obj1; // 隐式调用：同样是调用拷贝构造函数，注意这不是赋值！
```
常见形式如下：
```c++
class T {

public:

T(const T& other); // 拷贝构造函数（参数通常是 const 引用）

};
```

### 拷贝构造函数和拷贝赋值运算符
都用于对象的拷贝，用途、调用时机和行为有显著区别
| **特性** | **拷贝构造函数** | **拷贝赋值运算符** |
|----|----|----|
| **作用** | 初始化一个新对象（从已有对象拷贝） | 对已存在的对象赋值（覆盖原有值） |
| **语法** | `T(const T& other)` | `T& operator=(const T& other)` |
| **调用时机** | 对象**初始化**时（构造阶段） | 对象**已存在**时（赋值阶段） |
| **默认行为** | 浅拷贝（逐成员复制） | 浅拷贝（逐成员赋值） |
| **是否需要深拷贝** | 如果类管理资源（如动态内存），需要手动实现 | 同拷贝构造函数 |
| **禁用方式** | `T(const T&) = delete;` | `T& operator=(const T&) = delete;` |
| **典型调用场景** | T a = b;或T a(b); | a = b; |

### 拷贝构造函数
```c++
class Example {

public:

    int* data;

    // 构造函数

    Example(int val) { data = new int(val); }

    // 拷贝构造函数（深拷贝）

    Example(const Example& other) {

        data = new int(*other.data); // 分配新内存

    }

    ~Example() { delete data; }

};

int main() {

    Example obj1(10);

    Example obj2 = obj1; // 调用拷贝构造函数（初始化新对象）

}
```
### 拷贝赋值运算符
```c++

class Example {

public:

    int* data;

    Example(int val) { data = new int(val); }

    // 拷贝赋值运算符（深拷贝）

    Example& operator=(const Example& other) {

    if (this != &other) { // 防止自赋值

        delete data; // 释放原有资源

        data = new int(*other.data); // 分配新内存

    }

    return *this; // 返回当前对象的引用

    }

    ~Example() { delete data; }

};

int main() {

    Example obj1(10);

    Example obj2(20);

    obj2 = obj1; // 调用拷贝赋值运算符（覆盖已有对象）

}
```

### 拷贝构造函数的深拷贝和浅拷贝
#### 浅拷贝
1.  如果未定义拷贝构造函数，会自动生成一个浅拷贝版本
2.  逐成员复制：直接复制对象的每个成员的值
3.  风险：多个对象共享一块动态内存或资源，可能导致双重释放
示例：
```c++
class ShallowExample {

public:

    int* data;

    ShallowExample(int val) {

        data = new int(val); // 动态分配内存

    }

    // 编译器生成的默认拷贝构造函数（浅拷贝）

    ShallowExample(const ShallowExample& other) : data(other.data) {}

    ~ShallowExample() {

        delete data; // 释放内存

    }

};

int main() {

    ShallowExample obj1(10);

    ShallowExample obj2 = obj1; // 浅拷贝：obj2.data 和 obj1.data 指向同一内存

    // 程序结束时，obj1和obj2的析构函数会重复释放同一内存，导致崩溃！

}
```
#### 深拷贝
1.  需要自定义，显示分配新内存并复制内容
2.  每个对象拥有自己的资源副本
3.  避免双重释放和数据共享问题
示例：
```c++

class DeepExample {

public:

    int* data;

    DeepExample(int val) {

    data = new int(val); // 动态分配内存

}

    // 自定义拷贝构造函数（深拷贝）

    DeepExample(const DeepExample& other) {

    data = new int(*other.data); // 分配新内存并复制值

    }

// 拷贝赋值运算符（深拷贝，需处理自赋值）

    DeepExample& operator=(const DeepExample& other) {

    if (this != &other) { // 防止自赋值

        delete data; // 释放原有资源

        data = new int(*other.data); // 分配新内存并复制值

    }

    return *this;

    }

    ~DeepExample() {

        delete data; // 安全释放

    }

};

int main() {

    DeepExample obj1(10);

    DeepExample obj2 = obj1; // 深拷贝：obj2.data 是新分配的内存

    // 修改obj2不会影响obj1

    *obj2.data = 20;

    cout << *obj1.data; // 输出 10（obj1.data 未被修改）

}
```
### 禁用拷贝
显示删除拷贝构造和赋值运算符
```c++
class NonCopyable {

public:

    NonCopyable(const NonCopyable&) = delete; // 禁用拷贝构造

    NonCopyable& operator=(const NonCopyable&) = delete; // 禁用拷贝赋值
};
```

**总结**
1.  作用：用于通过拷贝一个已存在的对象来初始化一个新对象。
2.  默认行为：编译器会自动生成一个进行浅拷贝的版本。
3.  自定义时机（三大法则）：当你的类管理着动态资源（如堆内存）时，必须自定义拷贝构造函数进行深拷贝，否则会导致双重释放、悬空指针等问题。
**通常，如果你需要自定义析构函数来释放资源，那么你也需要自定义拷贝构造函数和拷贝赋值运算符。**
1.  参数：几乎总是const ClassName&。
2.  避免使用：对于大型对象或需要避免拷贝的场景，应考虑使用**移动语义**（C++11引入）。
