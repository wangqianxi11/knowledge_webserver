---
title: 析构函数
updated: 2025-08-22T19:06:31
created: 2025-05-10T09:38:53
---

### 类的析构函数：每次删除类的对象时执行，用于释放资源
名称与类的名称完全相同，只是在前面加了波浪号(~)作为前缀
不会返回任何值，也不能带有任何参数

**注意**：
- 析构函数可以是虚函数，对象销毁时需要通过虚表确定正确的析构顺序（尤其是基类指针指向派生类对象）
  - 基类指针指向派生类对象是**多态**的核心
```c++
Line::~Line(void)

{
cout << "Object is being deleted" << endl;
}
```
### 为什么实现多态的时候，析构函数一定要是虚函数？
如果基类析构函数不是虚函数，当使用基类指针删除子类对象时，子类的析构函数不会被调用，会导致内存泄漏
C++的析构是静态绑定，除非加上virtual

### 为什么不在所有析构函数前都加 virtual？
因为实现虚函数需要额外的开销（每个对象需要存储一个指向虚函数表的指针 vptr）。`如果一个类确定不会被继承用于多态，将其析构函数设为虚函数只会增加不必要的开销。`但在现代C++中，除非在极度资源受限的环境，否则这点开销通常可以忽略不计。当不确定时，将其设为虚函数通常是更安全的选择。

|特性	|非虚析构函数|	虚析构函数|
|--------|--------|--------|
函数调用机制|	静态绑定：根据指针/引用的类型决定调用哪个函数。	|动态绑定：根据指针/引用实际指向的对象决定调用哪个函数。
delete| basePtr 的行为	只调用基类的析构函数。	|先调用派生类的析构函数，再自动调用基类的析构函数。
后果	|资源泄漏。派生类独有的资源无法释放。|	资源安全。所有资源按正确顺序（从最派生到基类）被释放。
使用场景	|该类不打算作为基类使用，或者不会有基类指针指向派生类对象的情况。|	该类设计的目的就是作为基类（即多态基类），并且可能通过基类指针来删除派生类对象。
