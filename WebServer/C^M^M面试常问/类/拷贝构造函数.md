---
title: 拷贝构造函数
updated: 2025-08-22T19:14:15
created: 2025-05-10T09:39:48
---

拷贝构造函数
2025年5月10日
9:39

### 拷贝构造函数：创建对象时，使用同一类中之前创建的对象来初始化新创建的对象
- 通过使用另一个同类型的对象来初始化新创建的对象
- 复制对象把它作为参数传递给函数
- 复制对象，并从函数返回对象
**注意**
- 同样不能是虚函数
**如果类中没有定义，编译器会自行定义。如果类带有指针变量，并有动态内存分配，则必须有拷贝构造函数**
**特点：**
1.  函数名与类名相同。
2.  参数：必须是对本类类型的一个引用，几乎总是常量引用**(const MyClass&)**。
- 为什么是引用？如果不是引用，在传参时就需要调用拷贝构造函数自身来创建形参，这将导致无限递归调用，编译器会报错。
- 为什么是const？因为创建副本通常不应该修改源对象。
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>MyClass obj1; // 调用普通构造函数</p>
<p>MyClass obj2(obj1); // 显式调用：调用拷贝构造函数 MyClass::MyClass(const MyClass&amp;)</p>
<p>MyClass obj3 = obj1; // 隐式调用：同样是调用拷贝构造函数，注意这不是赋值！</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
常见形式如下：
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>class T {</p>
<p>public:</p>
<p>T(const T&amp; other); // 拷贝构造函数（参数通常是 const 引用）</p>
<p>};</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
例如，拷贝构造为
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Line::Line(int len)</p>
<p>{</p>
<p>cout &lt;&lt; "调用构造函数" &lt;&lt; endl;</p>
<p>// 为指针分配内存</p>
<p>ptr = new int;</p>
<p>*ptr = len;</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
则拷贝构造函数为
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Line::Line(const Line &amp;obj)</p>
<p>{</p>
<p>cout &lt;&lt; "调用拷贝构造函数并为指针 ptr 分配内存" &lt;&lt; endl;</p>
<p>ptr = new int;</p>
<p>*ptr = *obj.ptr; // 拷贝值</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
### 拷贝构造函数和拷贝赋值运算符
都用于对象的拷贝，用途、调用时机和行为有显著区别
| **特性** | **拷贝构造函数** | **拷贝赋值运算符** |
|----|----|----|
| **作用** | 初始化一个新对象（从已有对象拷贝） | 对已存在的对象赋值（覆盖原有值） |
| **语法** | ==T(const T& other)== | ==T& operator=(const T& other)== |
| **调用时机** | 对象**初始化**时（构造阶段） | 对象**已存在**时（赋值阶段） |
| **默认行为** | 浅拷贝（逐成员复制） | 浅拷贝（逐成员赋值） |
| **是否需要深拷贝** | 如果类管理资源（如动态内存），需要手动实现 | 同拷贝构造函数 |
| **禁用方式** | ==T(const T&) = delete;== | ==T& operator=(const T&) = delete;== |
| **典型调用场景** | ==T a = b;==或==T a(b);== | ==a = b;== |

1.  **拷贝构造函数**
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>class Example {</p>
<p>public:</p>
<p>int* data;</p>
<p>// 构造函数</p>
<p>Example(int val) { data = new int(val); }</p>
<p>// 拷贝构造函数（深拷贝）</p>
<p>Example(const Example&amp; other) {</p>
<p>data = new int(*other.data); // 分配新内存</p>
<p>}</p>
<p>~Example() { delete data; }</p>
<p>};</p>
<p></p>
<p>int main() {</p>
<p>Example obj1(10);</p>
<p>Example obj2 = obj1; // 调用拷贝构造函数（初始化新对象）</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
2.  **拷贝赋值运算符**
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>class Example {</p>
<p>public:</p>
<p>int* data;</p>
<p>Example(int val) { data = new int(val); }</p>
<p>// 拷贝赋值运算符（深拷贝）</p>
<p>Example&amp; operator=(const Example&amp; other) {</p>
<p>if (this != &amp;other) { // 防止自赋值</p>
<p>delete data; // 释放原有资源</p>
<p>data = new int(*other.data); // 分配新内存</p>
<p>}</p>
<p>return *this; // 返回当前对象的引用</p>
<p>}</p>
<p>~Example() { delete data; }</p>
<p>};</p>
<p></p>
<p>int main() {</p>
<p>Example obj1(10);</p>
<p>Example obj2(20);</p>
<p>obj2 = obj1; // 调用拷贝赋值运算符（覆盖已有对象）</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

### 拷贝构造函数的深拷贝和浅拷贝
#### 浅拷贝
1.  如果未定义拷贝构造函数，会自动生成一个浅拷贝版本
2.  逐成员复制：直接复制对象的每个成员的值
3.  风险：多个对象共享一块动态内存或资源，可能导致双重释放
示例：
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>class ShallowExample {</p>
<p>public:</p>
<p>int* data;</p>
<p>ShallowExample(int val) {</p>
<p>data = new int(val); // 动态分配内存</p>
<p>}</p>
<p>// 编译器生成的默认拷贝构造函数（浅拷贝）</p>
<p>ShallowExample(const ShallowExample&amp; other) : data(other.data) {}</p>
<p>~ShallowExample() {</p>
<p>delete data; // 释放内存</p>
<p>}</p>
<p>};</p>
<p></p>
<p>int main() {</p>
<p>ShallowExample obj1(10);</p>
<p>ShallowExample obj2 = obj1; // 浅拷贝：obj2.data 和 obj1.data 指向同一内存</p>
<p>// 程序结束时，obj1和obj2的析构函数会重复释放同一内存，导致崩溃！</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
#### 深拷贝
1.  需要自定义，显示分配新内存并复制内容
2.  每个对象拥有自己的资源副本
3.  避免双重释放和数据共享问题
示例：
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>class DeepExample {</p>
<p>public:</p>
<p>int* data;</p>
<p>DeepExample(int val) {</p>
<p>data = new int(val); // 动态分配内存</p>
<p>}</p>
<p>// 自定义拷贝构造函数（深拷贝）</p>
<p>DeepExample(const DeepExample&amp; other) {</p>
<p>data = new int(*other.data); // 分配新内存并复制值</p>
<p>}</p>
<p>// 拷贝赋值运算符（深拷贝，需处理自赋值）</p>
<p>DeepExample&amp; operator=(const DeepExample&amp; other) {</p>
<p>if (this != &amp;other) { // 防止自赋值</p>
<p>delete data; // 释放原有资源</p>
<p>data = new int(*other.data); // 分配新内存并复制值</p>
<p>}</p>
<p>return *this;</p>
<p>}</p>
<p>~DeepExample() {</p>
<p>delete data; // 安全释放</p>
<p>}</p>
<p>};</p>
<p></p>
<p>int main() {</p>
<p>DeepExample obj1(10);</p>
<p>DeepExample obj2 = obj1; // 深拷贝：obj2.data 是新分配的内存</p>
<p>// 修改obj2不会影响obj1</p>
<p>*obj2.data = 20;</p>
<p>cout &lt;&lt; *obj1.data; // 输出 10（obj1.data 未被修改）</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
### 禁用拷贝
显示删除拷贝构造和赋值运算符
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>class NonCopyable {</p>
<p>public:</p>
<p>NonCopyable(const NonCopyable&amp;) = delete; // 禁用拷贝构造</p>
<p>NonCopyable&amp; operator=(const NonCopyable&amp;) = delete; // 禁用拷贝赋值</p>
<p>};</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**总结**
1.  作用：用于通过拷贝一个已存在的对象来初始化一个新对象。
2.  默认行为：编译器会自动生成一个进行浅拷贝的版本。
3.  自定义时机（三大法则）：当你的类管理着动态资源（如堆内存）时，必须自定义拷贝构造函数进行深拷贝，否则会导致双重释放、悬空指针等问题。
**通常，如果你需要自定义析构函数来释放资源，那么你也需要自定义拷贝构造函数和拷贝赋值运算符。**
4.  参数：几乎总是const ClassName&。
5.  避免使用：对于大型对象或需要避免拷贝的场景，应考虑使用**移动语义**（C++11引入）。
