---
title: 一、创建型模式
updated: 2025-08-23T15:54:29
created: 2025-06-20T16:00:33
---

### Factory 模式（工厂模式）
**在面向对象系统设计中经常可以遇到以下的两类问题**：
- 我们经常会抽象出一些类的公共接口以形成抽象基类或者接口。这样我们可以通过声明一个指向基类的指针来指向实际的子类实现，达到了多态的目的。所以就不得不在要用到子类的地方写new 对象。这样实体类的使用者必须知道实际的子类名称，以及会使程序的扩展性和维护变得越来越困难。
- 还有一种情况就是在父类中并不知道具体要实例化哪一个具体的子类。只能在父类中写方法调用，具体调用哪一个类的方法交给子类实现。
#### 以上两个问题也就引出了 Factory 模式的两个最重要的功能：
**1）定义创建对象的接口，封装了对象的创建。**
**2）使得具体化类的工作延迟到了子类中。**

### AbstactFactory 模式（抽象工厂模式）
假如我们要买水果，水果的产地来自中国、日本、美国，每个国家的水果种类都可以分为苹果、香蕉、梨子。作为开发者，我们就不得不创建苹果类（香蕉和梨子类似），然后每种苹果都继承自苹果类。每上架一个国家的苹果我们都要实现一次苹果类，这样就会有成千上万的苹果类需要被创建，AbstractFactory 模式就是用来解决这类问题的：要创建一组相关或者相互依赖的对象。
实际上，AbstractFactory模式是为**创建一组（有多类）相关或依赖的对象提供创建接口**，而 Factory模式是为一类对象提供创建接口或延迟对象的创建到子类中实现。**并且可以看到，AbstractFactory模式通常都是使用 Factory 模式实现。**

### Singleton 模式（ 单例模式）
Singleton 模式是设计模式中最为简单、最为常见、最容易实现，也是最应该熟悉和掌握的模式。Singleton 模式就是一个类只创建一个唯一的对象，即一次创建多次使用。
**实现单例模式的步骤：**
1、**构造函数私有化**
2、增加静态私有的当前类的指针变量
3、**提供静态对外接口,可以让用户获得单例对象**
单例分为懒汉式和饿汉式
**懒汉式**：解决了饿汉式内存浪费问题，但是线程不安全的，可以通过互斥量mutex.lock()和mutex.unlock()来解决
**饿汉式**：还没有使用该单例对象，该单例对象就已经被加载到内存了，在对象过多时会造成内存浪费
### Builder 模式（建造者模式）
Builder 模式要解决的也正是这样的问题：当我们要创建的对象很复杂的时候（通常是由很多其他的对象组合而成），我们要要复杂对象的创建过程和这个对象的表示（展示）分离开来，**这样做的好处就是通过一步步的进行复杂对象的构建，由于在每一步的构造过程中可以引入参数，使得经过相同的步骤创建最后得到的对象的展示不一样。**
### Prototype 模式（原型模式）
**定义**：Prototype 模式也正是提供了自我复制的功能，就是说新对象的创建可以通过已有对象进行创建。在 C++中拷贝构造函数（Copy Constructor）曾经是很对程序员的噩梦，拷贝又分为浅拷贝和深拷贝
**浅拷贝**：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
**深拷贝**：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的
**Prototype 模式提供了一个通过已存在对象进行新对象创建的接口（Clone），Clone接口在 C++中我们将通过拷贝构造函数实现。**
