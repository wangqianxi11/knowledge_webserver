---
title: 智能指针
updated: 2025-08-22T16:52:41
created: 2025-04-15T10:45:01
---

因为C++使用内存的时候很容易出现**野指针**、**悬空指针**、**内存泄露**的问题。所以C++11引入了智能指针来管理内存。有四种：
- auto_ptr：已经不用了
- unique_ptr：独占式指针，同一时刻只能有一个指针指向同一个对象
- shared_ptr：共享式指针，同一时刻可以有多个指针指向同一个对象
- weak_ptr：用来解决shared_ptr相互引用导致的死锁问题

智能指针是一个**RAII类模板，用于动态分配内存**，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所执行的内存空间。

- **野指针**：一些内存单元已经释放，但是之前指向它的指针还在被使用
- **重复释放**：试图去释放已经释放的
- **内存泄露**：应该释放的没有被释放
- **悬空指针**：指向已经释放的内存的指针被称为悬空指针
- 内存泄漏和悬空指针的混合：在一些情况下，由于内存泄漏和悬空指针共同存在，程序可能会出现异常行为。

## std::unique_ptr
std::unique_ptr是一个独占所有权的智能指针，它保证指向的内存只能由一个unique_ptr拥有，不能共享所有权。

当unique_ptr超出作用域时，它所指向的内存会自动释放。

下面是个例子：
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p></th>
<th><p>#include &lt;memory&gt;</p>
<p>#include &lt;iostream&gt;</p>
<p></p>
<p>int main() {</p>
<p>std::unique_ptr&lt;int&gt; ptr(new int(10));</p>
<p>std::cout &lt;&lt; *ptr &lt;&lt; std::endl; // 输出10</p>
<p>// unique_ptr在超出作用域时自动释放所拥有的内存</p>
<p>return 0;</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
## std::shared_ptr
std::shared_ptr是一个共享所有权的智能指针，它允许多个shared_ptr指向同一个对象，当最后一个shared_ptr超出作用域时，所指向的内存才会被自动释放。

举个栗子：
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p></th>
<th><p>#include &lt;memory&gt;</p>
<p>#include &lt;iostream&gt;</p>
<p>int main() {</p>
<p>std::shared_ptr&lt;int&gt; ptr1(new int(10));</p>
<p>std::shared_ptr&lt;int&gt; ptr2 = ptr1; // 通过拷贝构造函数创建一个新的shared_ptr，此时引用计数为2</p>
<p>std::cout &lt;&lt; *ptr1 &lt;&lt; " " &lt;&lt; *ptr2 &lt;&lt; std::endl; // 输出10 10</p>
<p>// ptr2超出作用域时，所指向的内存不会被释放，因为此时ptr1仍然持有对该内存的引用</p>
<p>return 0;</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
总的来说，智能指针可以提高程序的安全性和可靠性，避免内存泄漏和悬空指针等问题。

但需要注意的是，智能指针不是万能的，也并不是一定要使用的，有些场景下手动管理内存可能更为合适。

**RAII的原理：**

**利用栈上局部变量的自动析构来保证资源一定会被释放。**

平常在C++编程过程中，会忘了释放资源，会导致内存泄漏。

但是变量的析构函数的调用是由编译器保证，一定会被执行，所以如果资源的获取和释放与对象的构造和析构绑定在一起，就不会出现资源泄露问题。

**智能指针，本质上是对资源所有权和生命周期管理的抽象：**
- 当资源是被独占时，使用 std::unique_ptr 对资源进行管理。
- 当资源会被共享时，使用 std::shared_ptr 对资源进行管理。
- 使用 std::weak_ptr 作为 std::shared_ptr 管理对象的观察者。
- 通过继承 std::enable_shared_from_this 来获取 this 的 std::shared_ptr 对象。
