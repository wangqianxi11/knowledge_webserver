---
title: 智能指针
updated: 2025-08-22T16:52:41
created: 2025-04-15T10:45:01
---

因为C++使用内存的时候很容易出现**野指针**、**悬空指针**、**内存泄露**的问题。所以C++11引入了智能指针来管理内存。有四种：
- auto_ptr：已经不用了
- unique_ptr：独占式指针，同一时刻只能有一个指针指向同一个对象
- shared_ptr：共享式指针，同一时刻可以有多个指针指向同一个对象
- weak_ptr：用来解决shared_ptr相互引用导致的死锁问题

智能指针是一个**RAII类模板，用于动态分配内存**，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所执行的内存空间。

- **野指针**：一些内存单元已经释放，但是之前指向它的指针还在被使用
- **重复释放**：试图去释放已经释放的
- **内存泄露**：应该释放的没有被释放
- **悬空指针**：指向已经释放的内存的指针被称为悬空指针
- 内存泄漏和悬空指针的混合：在一些情况下，由于内存泄漏和悬空指针共同存在，程序可能会出现异常行为。

### 智能指针超出作用域
<strong style="color:red">在代码执行过程中，程序离开了定义某个智能指针（如 std::unique_ptr 或 std::shared_ptr）的代码块（即作用域 {}），此时该智能指针会自动被销毁。</strong>

这个行为的关键后果是：**智能指针在销毁时，会自动调用其析构函数，从而释放它所管理的动态分配的内存**。这意味着你无需手动使用 delete 来释放内存，避免了内存泄漏。

#### 普通指针和智能指针的对比
##### 普通指针
```c++
void problemFunction() {
    int* raw_ptr = new int(42); // 在堆上分配内存

    // ... 使用这个指针做一些操作 ...

    // 函数结束，raw_ptr 这个指针变量本身（存储在栈上）会被销毁。
    // 但是！它指向的那块堆内存 (int with value 42) 并没有被释放！
    // 这就是“内存泄漏”。
}
```
- `raw_ptr 本身是局部变量，存储在栈上`。函数结束时，栈内存被清理，raw_ptr 这个变量不复存在。

- `new int(42) 分配的内存是在堆上，它的生命周期不依赖于作用域`。如果你不手动 delete raw_ptr;，这块内存就会一直占用，造成内存泄漏。
  
##### 智能指针
<strong style="color:red">智能指针将堆内存的生命周期与栈上智能指针对象的生命周期绑定在一起。</strong>
```c++
#include <memory>

void smartFunction() {
    { // 开始一个内部作用域

        std::unique_ptr<int> smart_ptr = std::make_unique<int>(42); // 在堆上分配内存，并由smart_ptr管理

        // ... 使用 smart_ptr ...

    } // **作用域结束！**
    // 此时，smart_ptr 即将被销毁。
    // 在销毁前，std::unique_ptr<int> 的析构函数会被自动调用。
    // 在这个析构函数中，会自动执行 `delete` 操作来释放它托管的那个 int 内存。
    // 内存被安全释放，无内存泄漏。
}
```
1. 进入 {} 作用域，smart_ptr 被创建，它管理一块堆内存。

2. 离开 } 时，smart_ptr 作为栈对象，它的生命周期结束。

3. C++ 机制保证，在销毁一个对象前，一定会先调用它的析构函数。

4. std::unique_ptr 的析构函数里写好了 delete 语句来释放它托管的指针。

5. 内存被成功释放。程序无需手动干预。

### std::unique_ptr
std::unique_ptr是一个独占所有权的智能指针，它保证指向的内存只能由一个unique_ptr拥有，不能共享所有权。

当unique_ptr超出作用域时，它所指向的内存会自动释放。

下面是个例子：
```c++
#include <memory>

#include <iostream>

int main() {

std::unique_ptr<int> ptr(new int(10));

std::cout << *ptr << std::endl; // 输出10

// unique_ptr在超出作用域时自动释放所拥有的内存

return 0;

}
```
## std::shared_ptr
std::shared_ptr是一个共享所有权的智能指针，它允许多个shared_ptr指向同一个对象，当最后一个shared_ptr超出作用域时，所指向的内存才会被自动释放。

举个栗子：
```c++
#include <memory>

#include <iostream>

int main() {

std::shared_ptr<int> ptr1(new int(10));

std::shared_ptr<int> ptr2 = ptr1; // 通过拷贝构造函数创建一个新的shared_ptr，此时引用计数为2

std::cout << *ptr1 << " " << *ptr2 << std::endl; // 输出10 10

// ptr2超出作用域时，所指向的内存不会被释放，因为此时ptr1仍然持有对该内存的引用

return 0;

}
```
总的来说，**智能指针可以提高程序的安全性和可靠性，避免内存泄漏和悬空指针等问题**。

但需要注意的是，智能指针不是万能的，也并不是一定要使用的，有些场景下手动管理内存可能更为合适。

### RAII的原理：

**利用栈上局部变量的自动析构来保证资源一定会被释放。**

平常在C++编程过程中，会忘了释放资源，会导致内存泄漏。

但是变量的析构函数的调用是由编译器保证，一定会被执行，所以如果资源的获取和释放与对象的构造和析构绑定在一起，就不会出现资源泄露问题。

### 智能指针，本质上是对资源所有权和生命周期管理的抽象：
- 当资源是被独占时，使用 std::unique_ptr 对资源进行管理。
- 当资源会被共享时，使用 std::shared_ptr 对资源进行管理。
- 使用 std::weak_ptr 作为 std::shared_ptr 管理对象的观察者。
- 通过继承 std::enable_shared_from_this 来获取 this 的 std::shared_ptr 对象。
