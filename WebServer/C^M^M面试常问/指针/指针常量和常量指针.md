## 1. 常量指针 (Pointer to Constant)
“常量”修饰的是指针所指向的数据，意味着不能通过这个指针来修改它所指向的值。但是，指针本身可以改变，即可以指向另一个地址。

语法： ```const <类型> * <指针名>; 或 <类型> const * <指针名>;```

```c++
int a = 10;
int b = 20;

// 定义一个常量指针，指向整型常量
const int *p = &a; // 或者 int const *p = &a;

// 1. 可以通过指针读取数据
printf("%d\n", *p); // 输出：10

// 2. 错误！不能通过指针p修改它所指向的内存的值
// *p = 30; // 编译错误 (assignment of read-only location '*p')

// 3. 正确！指针p本身的值（存储的地址）可以改变，可以指向别的变量
p = &b; // 现在 p 指向了 b
printf("%d\n", *p); // 输出：20

// 4. 虽然不能通过p修改，但可以直接修改变量本身
a = 100;
printf("%d\n", *p); // 输出：100，因为p仍然指向a，a的值已经变了
```
### 主要应用场景：
#### 1. 函数参数 - 最重要的用途！
这是最广泛、最关键的用途。当你想向函数传递一个参数（通常是数组、结构体等大型数据），又不希望函数内部意外修改原始数据时，就使用常量指针。

保护原始数据：防止函数内部的代码误操作，修改了调用者的数据。

表达意图：函数声明清楚地告诉调用者：“放心吧，你的数据在我这里只是只读的”。

兼容性：可以接受常量或非常量数据的地址，应用更广泛。

#### 2. 访问只读内存
指向存储在只读内存段（如Flash、ROM）的数据，或者通过硬件映射的只读寄存器。任何试图修改的操作都会在编译期或运行期被捕获。


## 2. 指针常量 (Constant Pointer)
“常量”修饰的是指针变量本身，意味着指针存储的地址（指向谁）是固定的，不能再指向别的地址。但是，可以通过这个指针来修改它所指向地址的值。

语法： ```<类型> * const <指针名>;```
```c++
int a = 10;
int b = 20;

// 定义一个指针常量，必须初始化（因为之后不能再改变指向）
int * const p = &a;

// 1. 正确！可以通过指针p修改它所指向的内存的值
*p = 30;
printf("a = %d\n", a); // 输出：a = 30

// 2. 错误！指针p本身是常量，不能再指向别的变量
// p = &b; // 编译错误 (assignment of read-only variable 'p')

// 3. 指针指向的值和变量本身都可以被修改（通过其他途径）
a = 40; // 正确
(*p)++; // 正确，通过p将a的值+1
printf("a = %d\n", a); // 输出：a = 41
```

### 主要应用场景：
#### 1. 硬件寄存器映射
在嵌入式系统开发中非常常见。某个外设（如GPIO、UART、ADC）的寄存器地址是固定不变的。我们会定义一个指针常量来指向这个绝对地址，然后通过这个指针来配置寄存器。

#### 2. 资源句柄或管理器
当一个模块需要持有一个资源的访问点并且这个访问点在生命周期内不变时。例如，一个文件操作模块在打开文件后，其内部的文件指针就不应再改变，直到文件被关闭。