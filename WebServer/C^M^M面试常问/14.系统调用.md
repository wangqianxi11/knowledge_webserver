---
title: 系统调用
updated: 2025-05-20T15:58:48
created: 2025-04-29T16:29:39
---

系统调用是<b><font color="red">操作系统提供给用户程序访问内核功能和硬件资源的编程接口，是用户空间与内核空间交互的桥梁。</font></b>

核心概念
### 定义：
- 系统调用是操作系统内核提供的一组受保护的接口
- 允许用户态程序请求内核服务（如文件操作、进程控制、设备访问等）
### 保护机制
通过软中断（如x86的int 0x80）或专用指令（如syscall/sysenter）触发
- 引起处理器从用户态切换到内核态（特权级别提升）
#### 工作原理
- 用户程序准备调用参数
- 执行特殊指令触发软中断
- CPU切换到内核模式
- 内核验证参数并执行请求
- 返回结果给用户程序

用户空间（User Space）和内核空间（Kernel Space）的交互是操作系统核心机制之一，主要涉及<b>系统调用（System Calls）、内存映射、信号、文件系统、进程间通信（IPC）</b>等方式。以下是常见的交互手段及其特点：

# 系统调用（System Calls）

**作用**：用户程序通过<b>软中断（如int 0x80/syscall）</b>主动请求内核服务。

## 常见系统调用：
- **文件/设备操作**：
    > open()、read()、write()、ioctl()
- **进程管理**：
     > fork()、execve()、exit()
- **网络通信**：
    >socket()、bind()、send()、recv()
- **内存管理**：
    >mmap()、brk()

**特点**：
- **上下文切换开销**：用户态 → 内核态切换（CPU 特权级变化）。
- **安全性**：内核会检查参数合法性（如指针是否属于用户空间）。
**示例**：
```c++
int fd = open("file.txt", O_RDONLY); // 用户态调用，触发内核文件系统操作 
```

# 内存映射（Memory Mapping）

**作用**：将内核空间的数据（如文件、设备内存）映射到用户空间，避免频繁系统调用。

**常见方法**：
- **文件映射**：
  >mmap()
- **设备内存映射**：
  >/dev/mem（需 root 权限）

**特点**：
- **零拷贝（Zero-Copy）**：用户程序直接访问映射的内存，减少数据拷贝。
- **共享内存**：多个进程可映射同一文件/内存区域（IPC 用途）。

**示例**：
```c++
void *addr = mmap(NULL, 4096, PROT_READ, MAP_SHARED, fd, 0); // 文件映射到用户空间 
```
# 信号（Signals）

**作用**：内核向用户进程发送异步事件通知（如<b>SIGINT、SIGSEGV）</b>。

**常见场景**：
- **进程控制**：`kill()`、`SIGTERM（终止进程）`
- **异常处理**：SIGSEGV（段错误）、SIGFPE（除零错误）
  
**特点**：
- **异步中断**：信号处理函数（Signal Handler）在用户态执行。
- **局限性**：不能传递复杂数据，仅用于简单通知。

**示例**：
```c++
void handler(int sig) { printf("Received SIGINT!\n"); }

signal(SIGINT, handler); // 注册信号处理函数
```

# 4. 文件系统（/proc、/sys）

**作用**：通过虚拟文件系统（VFS）暴露内核信息或配置接口。

**常见用例**：
- **查询系统信息**：/proc/cpuinfo、/proc/meminfo
- **动态配置内核参数**：/sys/class/net/eth0/mtu

**特点**：
- **读写即交互**：用户程序用read()/write()操作这些文件即可与内核交互。
- **无需专用 API**：普通文件操作即可完成。

**示例**：
```bash

cat /proc/cpuinfo # 查看 CPU 信息

echo 1500 > /sys/class/net/eth0/mtu # 修改网卡 MTU

```

# 进程间通信（IPC）

**作用**：用户进程通过内核提供的机制交换数据。

**常见方式**：
| **机制** | **描述** | **内核角色** |  |
|----|----|----|----|
| **管道（Pipe）** | 单向数据传输（如 `ls\|grep foo`） | 内核维护缓冲区 |
| **共享内存** | 多进程访问同一内存区域 | 内核分配并管理共享内存段 |  |
| **消息队列** | 结构化数据传递（如 POSIX MQ） | 内核充当消息中转站 |  |
| **Socket** | 跨网络或本机通信（如 TCP/UDP） | 内核处理协议栈和缓冲 |  

**特点**：
- **内核作为中介**：数据需经过内核缓冲区（共享内存除外）。
- **同步/异步支持**：如 Socket 可设为非阻塞模式。

# 6. 设备文件（/dev）

**作用**：通过设备驱动与硬件交互。

**常见操作**：
- **字符设备**（如键盘、串口）：read()、write()
- **块设备**（如磁盘）：ioctl()发送控制命令
**示例**：
```c++
int fd = open("/dev/ttyS0", O_RDWR); // 打开串口

ioctl(fd, SET_BAUDRATE, 9600); // 设置波特率（依赖驱动支持）
```

# 7. 其他机制

**（1）Netlink Socket**
- **用途**：用户态与内核态双向通信（如网络配置工具iproute2）。
- **优势**：比==ioctl==更灵活，支持多播和异步消息。

**（2）eBPF（Extended Berkeley Packet Filter）**
- **用途**：用户态向内核注入安全可控的字节码（用于网络监控、性能分析）。
- **示例**：tcpdump利用 eBPF 抓包。
  

# 总结：用户态与内核态交互方式对比
| **机制** | **方向** | **数据量** | **延迟** | **典型用例** |
|----|----|----|----|----|
| **系统调用** | 用户 → 内核 | 小 | 中 | 文件操作、进程管理 |
| **内存映射** | 双向（共享内存） | 大 | 低 | 高性能文件 I/O、IPC |
| **信号** | 内核 → 用户 | 极小 | 异步 | 异常处理、进程控制 |
| **/proc /sys** | 双向（文件接口） | 小 | 中 | 系统信息查询、参数配置 |
| **IPC** | 用户 ↔ 用户（经内核） | 中到大 | 中到高 | 进程间数据交换 |
| **设备文件** | 用户 ↔ 驱动 | 可变 | 依赖设备 | 硬件控制（如显卡、传感器） |
