---
title: 引用
updated: 2025-08-22T16:47:00
created: 2025-04-15T10:53:55
---


**引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。**

一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

**引用必须在定义时初始化，并且一旦绑定到一个变量后，就不能再绑定到其他变量。**

引用的语法如下：
```c++
int a = 10;

int &ref = a; // ref 是 a 的引用
```

- <b>int &ref</b>表示ref是一个int类型的引用。
- ref是a的别名，<b>对ref的操作会直接作用于a。</b>

### C++ 引用 vs 指针

引用很容易与指针混淆，它们之间有三个主要的不同：
- **不存在空引用**，引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，**就不能被指向到另一个对象**。指针可以在任何时候指向到另一个对象。
- 引用必须在**创建时被初始化**。指针可以在任何时间被初始化。
- **引用的对象必须是一个变量，而指针必须是一个地址**。

| **特性** | **引用** | **指针** |
|----|----|----|
| **定义与初始化** | 必须初始化，且不能为null。 | 可以不初始化，可以在后续代码中指向其他对象，可以为null。 |
| **语法** | 使用&声明，例如：int &ref = a; | 使用\*声明，例如：int \*ptr = &a; |
| **重新绑定** | 不能重新绑定，一旦初始化后始终引用同一个对象。 | 可以重新指向其他对象，例如：ptr = &b; |
| **空值（Nullability）** | 不能为null，必须绑定到有效的对象。 | 可以为null，表示不指向任何对象。 |
| **内存占用** | 不占用额外内存（编译器通常将其优化为直接操作所引用的对象）。 | 占用额外内存（存储地址，通常是一个机器字长，如4字节或8字节）。 |
| **访问方式** | 直接使用，无需解引用操作符，例如：ref = 10; | 需要使用\*解引用操作符访问或修改所指向的对象，例如：\*ptr = 10; |
| **多级间接访问** | 不支持多级间接访问（不能有引用的引用）。 | 支持多级间接访问（如指针的指针：int \*\*pptr;）。 |
| **函数参数传递** | 常用于函数参数传递，语法简洁，例如：void func(int &x) { x = 10; } | 也可以用于函数参数传递，但需要使用解引用操作符，例如：void func(int \*x) { \*x = 10; } |
| **数组与引用** | 不能直接创建引用数组，但可以创建数组的引用，例如：int (&ref)\[10\] = arr; | 可以创建指针数组，也可以创建指向数组的指针，例如：int \*ptrArr\[10\]; |
| **安全性** | 更安全，不能为null，且语法更直观。 | 更灵活，但容易出错（如空指针、野指针等）。 |
| **底层实现** | 通常通过指针实现，但编译器会优化为直接操作所引用的对象。 | 直接存储目标对象的内存地址。 |

## 2.2 右值引用
再看下右值引用，右值引用的标志是<b>&&</b>，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值：

右值引用为我们提供了一种合法地“识别”和“利用”临时对象的方法，从而**允许我们将资源从一个对象高效地转移到另一个对象，而不是进行昂贵的复制**。

**右值引用是**为一个临时变量取别名，它只能绑定到一个临时变量或表达式（将亡值）上。实际开发中我们可能需要对右值进行修改（实现移动语义时就需要）而右值引用可以对右值进行修改。
```c++
int a = 10;

int& lref = a; // 正确：左值引用绑定到左值

// int& lref2 = 20; // 错误：左值引用不能绑定到右值

int&& rref1 = 20; // 正确：右值引用绑定到字面量右值

// int&& rref2 = a; // 错误：右值引用不能绑定到左值

std::string getString() { return "Hello"; }

std::string&& sref = getString(); // 正确：函数返回的临时string是右值
```
**关键特性**：**右值引用延长了所绑定临时对象的生命周期**。原本getString()返回的临时对象在分号;后就会销毁，但被sref这个右值引用绑定后，它的生命周期会延长到sref的作用域结束。

**为什么**：

1.为了支持**移动语义--解决了C++中长期存在的不必要的深拷贝性能问题**，右值引用可以绑定到临时对象、表达式等右值上，这些右值在生命周期结束后就会被销毁，因此可以在右值引用中窃取其资源，从而避免昂贵的复制操作，实现高效的移动语义。

2.**完美转发**：右值引用可以绑定到任何类型的右值上，可以将其作为参数传递给函数，并在函数内部将其“转发”到其他函数中，从而实现完美转发。

3.拓展可变参数模板，实现更加灵活的模板编程。
