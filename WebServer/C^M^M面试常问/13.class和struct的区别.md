---
title: class和struct的区别
updated: 2025-04-15T15:24:08
created: 2025-04-15T11:13:09
---

默认继承权限不同：class默认继承的是private继承，struct默认是public继承。<br>

Class还可用于定义模板参数，但是关键字struct不能同于定义模板参数，C++保留struct关键字，原因是保证与C语言的向下兼容性，为了保证百分百的与C语言中的struct向下兼容，，C++把最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性的限制。

C++ 中的 struct 和 class 基本是通用的，唯有几个细节不同：
- class 中类中的成员默认都是 private 属性的。
- 而在 struct 中结构体中的成员默认都是 public 属性的。
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
- class 可以用于定义模板参数，struct 不能用于定义模板参数。

# 联合体（Union） 和 结构体（Struct）
### 核心区别对比表

|特性|	结构体 (Struct)|	联合体 (Union)|
|:------:|-----------|----------------|
|内存布局|	所有成员占用独立的内存空间	|所有成员共享同一块内存空间
|内存大小	|>= 所有成员大小之和（可能有内存对齐带来的填充）	|= 最大成员的大小（同样考虑内存对齐）
|成员访问|	所有成员可以同时被访问和修改|	所有成员不能同时有效，修改一个成员会覆盖其他成员
|用途|	将逻辑上相关但类型不同的数据组合在一起|	在同一内存位置存储不同类型的数据，

## 内存布局（最根本的区别）
```c++
// 结构体
struct MyStruct {
    int id;       // 4字节
    char name[20]; // 20字节
    float score;   // 4字节
}; // 总大小很可能为 28 字节 (4+20+4，考虑对齐)

// 联合体
union MyUnion {
    int int_val;   // 4字节
    char str[20];  // 20字节
    float float_val; // 4字节
}; // 总大小为 20 字节 (取最大成员 char str[20] 的大小)
```
内存示意图：
```plaintext
结构体 MyStruct (约28字节)
+----+----------------------+----+
| id |        name          |score|
+----+----------------------+----+

联合体 MyUnion (20字节)
+----------------------+
|     共享内存区域       | <-- int_val, str[], float_val 都从这里开始
+----------------------+
```
- 你为 `MyStruct` 变量分配内存时，系统会分配足够放下所有三个成员的空间。

- 你为 `MyUnion` 变量分配内存时，系统只会分配一块足够放下最大成员（str[20]）的空间。所有成员都从这块内存的起始地址开始。

## 成员访问
```c++
union MyUnion u;

u.int_val = 0x12345678; // 向共享内存写入一个整数
printf("Integer: %x\n", u.int_val); // 输出: 12345678

u.float_val = 3.14;     // **覆盖**刚才的整数，写入一个浮点数
printf("Float: %f\n", u.float_val); // 输出: 3.140000
printf("Integer now: %x\n", u.int_val); // **输出是未定义的！** 你得到的是浮点数 3.14 的二进制解释，不是一个有效的整数。
```
**关键**：在联合体中，你最后一次写入的成员是唯一有效的成员。读取未最后写入的成员会导致未定义行为（垃圾值）。

而在结构体中，每个成员都是独立的：
```c++
struct MyStruct s;
s.id = 10;
s.score = 95.5;
// 修改 score 完全不会影响 id 和 name 的值
```

## 典型应用场景
### 结构体的应用场景（无处不在）
结构体用于将不同类型的数据打包成一个新的复合数据类型。

- 表示一个概念实体：如 Student, Employee, Point。

- 函数参数和返回值：将多个相关参数打包成一个结构体，方便传递。

- 数据结构：链表节点、树节点等。

- 与硬件或协议交互：定义与数据包格式、文件头等严格匹配的内存布局。

### 联合体的应用场景（节省内存、类型双关）
联合体通常用于一些特定的、需要节省内存或灵活解释数据的场景。

#### 1.节省内存（最主要用途）
当你有多个数据成员，但**同一时间只会使用其中一个时**，使用联合体可以极大节省内存。这在嵌入式开发中非常常见。
```c++
// 表示一个配置数据，它可以是整数、浮点数或字符串，但一次只使用一种
union ConfigValue {
    int int_value;
    float float_value;
    char string_value[20];
};

struct Setting {
    char name[50];
    enum ValueType type; // 用一个枚举来标记当前联合体中存储的是哪种类型
    union ConfigValue value; // 实际的值
};
```

#### 2.类型双关（Type Punning）
将同一段内存解释为不同的数据类型。常用于低级编程、协议解析、数据转换。
```c++
union Converter {
    uint32_t integer;
    uint8_t bytes[4];
    float float_num;
};

union Converter c;
c.integer = 0x12345678;
printf("Byte 0: %02x\n", c.bytes[0]); // 在小端机器上输出: 78
printf("Byte 1: %02x\n", c.bytes[1]); // 56
// 这允许我们轻松地访问一个整数的各个字节

c.float_num = 3.14;
printf("IEEE754 representation: %08x\n", c.integer);
// 这允许我们查看浮点数的底层二进制表示
```

#### 3.实现变体类型（Variant）
类似于上面的 ConfigValue 例子，是实现动态类型语言中“变量可以存储任何类型”的基础。