---
title: 悲观锁和乐观锁
updated: 2025-06-14T15:42:14
created: 2025-06-13T16:23:13
---

数据库中的 **乐观锁** 和 **悲观锁** 是两种并发控制策略，用于防止数据在高并发访问时发生冲突，确保数据的一致性与完整性。它们的**核心区别**在于：
- **悲观锁**：认为冲突随时可能发生，**先上锁再操作**
- **乐观锁**：认为冲突很少发生，**操作前不加锁，提交前校验**
下面我将详细介绍两者的原理与实现方式（包括 SQL 示例）。

**一、悲观锁（Pessimistic Lock）**

**原理：**
- 在访问数据之前就加锁，**阻止其他事务同时读/写该数据**。
- 适用于**写多读少**、**冲突频繁**的场景。
**实现方式（数据库原生支持）：**

**MySQL InnoDB 示例：**  
```sql
START TRANSACTION;  
SELECT * FROM products WHERE id = 1 FOR UPDATE;  
```
-- 此时锁定了 id = 1 的那一行，其他事务不能读/写
```sql
UPDATE products SET stock = stock - 1 WHERE id = 1;  
COMMIT;
```
**解释：**
- FOR UPDATE 会加**排他锁**（X锁），直到事务提交或回滚。
- 其他事务若执行类似语句，会被阻塞等待或死锁处理。

**二、乐观锁（Optimistic Lock）**

**原理：**
- 操作数据时**不加锁**，而是在提交时**检查是否有其他事务修改过数据**。
- 通常依靠\*\*版本号（version）**或**时间戳（timestamp）\*\*字段。
**实现方式（手动实现，数据库不自动支持）**

**示例表结构：**
```sql
CREATE TABLE products (  
id INT PRIMARY KEY,  
name VARCHAR(50),  
stock INT,  
version INT  
);
```
**更新逻辑（伪代码 or 事务中）：**

-- 查询当前版本号  
```sql
SELECT stock, version FROM products WHERE id = 1;
```
-- 假设读到 version = 3  
-- 尝试更新时增加版本号  
```sql
UPDATE products  
SET stock = stock - 1, version = version + 1  
WHERE id = 1 AND version = 3;
```
**解释：**
- 若版本号匹配，说明没人修改过，更新成功（受影响行数 = 1）。
- 若版本号不匹配，说明数据被其他事务修改过，**更新失败（行数=0）**，程序应回滚或重试。

- 乐观锁**需要开发者自行处理失败重试机制**；
- 悲观锁若使用不当，容易**引发死锁或性能瓶颈**；
- 乐观锁常用于**NoSQL数据库、REST API 后端**；
- 悲观锁常用于**强事务一致性要求的传统数据库系统**。

