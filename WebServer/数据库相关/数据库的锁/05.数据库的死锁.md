---
title: 数据库的死锁
updated: 2025-06-13T16:27:16
created: 2025-06-13T16:26:37
---

数据库中的**死锁（Deadlock）是指两个或多个事务在执行过程中，互相等待对方释放锁资源，从而造成永远无法继续执行**的状态。

### 一、什么是死锁？
**定义：**
当两个（或多个）事务互相持有对方**所需资源的锁**，并且都在等待对方释放锁，但**谁也不释放**，就进入了死锁。

**类比：**
就像两个人在一条狭路上面对面走来，**互相都不让路，也都走不了**。

### 二、死锁产生的典型条件（必要条件）
根据计算机操作系统原理，**死锁产生的四个条件**：
1.  **互斥条件**：资源不能共享。
2.  **请求与保持**：事务持有资源的同时请求其他资源。
3.  **不剥夺条件**：资源不能被强制剥夺。
4.  **循环等待**：形成事务间的循环资源等待链。
只要同时满足这四个条件，就可能出现死锁。
### 三、死锁示例（以 MySQL InnoDB 为例）

- 事务 A  
```sql
START TRANSACTION;  
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
```
- 此时事务 B  
```sql
START TRANSACTION;  
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
```
- 回到事务 A：尝试访问事务 B 已锁定的数据  
```sql
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
```
- 回到事务 B：尝试访问事务 A 已锁定的数据  
```sql
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
```
结果：
- A 等待 B 释放 id=2 的锁；
- B 等待 A 释放 id=1 的锁；
- **互相等待，发生死锁。**

### 四、数据库如何处理死锁？
不同数据库策略不同：
| **数据库** | **死锁处理策略** |
|----|----|
| **MySQL（InnoDB）** | 自动检测死锁，**回滚其中一个事务**（通常是等待时间短的） |
| **Oracle** | 不检测死锁，**通过等待超时报错**处理 |
| **SQL Server** | 检测死锁并选择“牺牲品”事务回滚 |

### 五、如何预防/避免死锁？
**1. 固定资源访问顺序**
- 所有事务**按相同顺序访问表或行**，防止循环等待。

**2. 一次性申请所有所需资源**
- 避免中途申请新锁，减少死锁机会。

**3. 使用较短的事务**
- 避免长时间持有锁。

**4. 合理设置索引**
- 减少无效全表扫描导致的大范围锁。

**5. 使用锁粒度小的引擎（如 InnoDB）**
- 比如用行锁代替表锁，减少冲突范围。
