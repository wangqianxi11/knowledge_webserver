---
title: 数据库锁的类型
updated: 2025-06-15T17:06:10
created: 2025-06-13T16:10:21
---

数据库中的锁类型可以从不同维度来分类，主要包括**粒度维度**、**操作意图维度**、**锁实现方式维度**等。下面我将系统地为你列出常见的锁类型：

### 一、按锁粒度分类
#### 1. 表级锁（Table Lock）
- 作用于整张表。
- 并发性较差，但加锁开销小。
- 适合批量操作场景。
- 常见于 MyISAM 引擎（MySQL）。

#### 2. 行级锁（Row Lock）
- 仅锁定被操作的数据行。
- 并发性高，但加锁开销较大。
- 支持高并发事务处理。
- 常见于 InnoDB 引擎。
#### 3. 页级锁（Page Lock）
- 锁定数据页（多行记录组成的存储单元）。
- MySQL 不常用，SQL Server/Oracle 更常见。

### 二、按锁类型/行为意图分类
#### 1. 共享锁（Shared Lock，S锁）
- 多个事务可以同时读取数据（共享）。
- 不允许修改（防止写冲突）。
- 适用于 SELECT … LOCK IN SHARE MODE。
#### 2. 排他锁（Exclusive Lock，X锁）
- 事务独占数据，其他事务不能读也不能写。
- 用于 UPDATE、DELETE、INSERT。
#### 3. 意向锁（Intent Lock）
- 表级别的声明式锁，表示事务将会在某些行上加 S/X 锁。
- 用于加速锁冲突检测。
  - **IS（意向共享锁）**
  - **IX（意向排他锁）**
  - **SIX（共享 + 意向排他锁）**
意向锁并不阻止实际操作，而是用于配合多粒度锁的判断机制。
#### 4. 间隙锁（Gap Lock）（InnoDB 专属）
- 锁定两个记录之间的“空隙”，防止其他事务插入。
- 用于防止幻读。
#### 5. 临键锁（Next-Key Lock）
- 是**行锁 + 间隙锁**的组合。
- 锁住当前行及其之后的间隙，常用于 Repeatable Read 隔离级别。

### 三、按实现策略分类**
#### 1. 悲观锁（Pessimistic Lock）
- 预期数据会被并发修改，操作前先加锁。
- 强制控制访问，牺牲并发性换一致性。
- 实现方式：数据库原生锁机制（如 SELECT ... FOR UPDATE）。
#### 2. 乐观锁（Optimistic Lock）
- 假设冲突不常发生，不加锁，而是依赖**版本号/时间戳**。
- 更新前检查数据是否被其他事务修改。
- 实现方式：应用层维护版本字段，例如 UPDATE … WHERE version = old_version。
