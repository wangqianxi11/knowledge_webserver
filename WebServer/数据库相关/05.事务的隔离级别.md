---
title: 事务的隔离级别
updated: 2025-06-15T16:54:58
created: 2025-04-15T10:11:37
---

- **脏读**是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

- **不可重复读**是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。

- **幻读** 指的是在一个事务内，相同的查询条件执行两次，但第二次查询返回了第一次查询时未返回的新行（这些新行是其他事务插入并提交的）。
  - 假设事务要新增一条记录，主键为id，在新增之前执行了select，没有发现id为xxx的记录，但插入时出现主键冲突，这就属于幻读，读取不到记录却发现主键冲突是因为记录实际上已经被其他的事务插入了，但当前事务不可见。

**不可重复读和脏读的区别是**，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

### 幻读 vs 不可重复读
很多人容易混淆幻读和不可重复读，它们的区别至关重要：

| 现象       | 关注点                            | 操作类型 | 例子                                                                               |
| ---------- | --------------------------------- | -------- | ---------------------------------------------------------------------------------- |
| 不可重复读 | <b>同一行数据的内容</b>发生了变化 | UPDATE   | 事务内两次读取id=1的用户年龄，第一次25岁，第二次变成26岁（其他事务修改了）。       |
| 幻读       | <b>结果集的行数</b>发生了变化     | INSERT   | 事务内两次执行WHERE age>20，第一次返回2行，第二次返回3行（其他事务插入了新数据）。 |

### 脏读和幻读
| 特性     | 脏读 (Dirty Read)                  | 幻读 (Phantom Read)       |
| -------- | ---------------------------------- | ------------------------- |
| 本质     | 读到了<b>未提交的数据</b>                 | 读到了<b>新插入的已提交数据</b>  |
| 操作类型 | UPDATE（更新）或DELETE（删除）     | INSERT（插入）            |
| 数据状态 | 事务中间状态、可能被回滚的无效数据 | 已经提交的有效数据        |
| 严重性   | <b>非常严重，数据一致性被破坏</b>         | 相对较轻，取决于业务逻辑  |
| 比喻     | 看到别人的草稿                     | 看到别人新发布的内容      |
| 解决级别 | 读已提交及以上                     | 可重复读（MySQL）或序列化 |
#### 关键区别总结
- 数据有效性不同：

  - 脏读：读的是**无效的、可能不存在**的数据

  - 幻读：读的是**有效的、真实存在**的数据

- 业务影响不同：

  - 脏读：可能导致灾难性后果（如基于错误数据做决策）

  - 幻读：通常影响统计、报表类操作，可能只是让人困惑

- 解决难度不同：

  - 脏读：很容易解决，只需读已提交隔离级别

  - 幻读：较难解决，需要可重复读或序列化级别

## MySQL数据库为我们提供的四种隔离级别：
- <b>Serializable(串行化)</b>：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
- <b>Repeatable read(可重复读)</b>：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。
- <b>Read committed(读已提交)</b>：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。
- <b>Read uncommitted(读未提交)</b>：所有事务都可以看到其他未提交事务的执行结果。

## MySQL 的全局或会话默认隔离级别
默认情况下，InnoDB 存储引擎 使用的是：**REPEATABLE READ（可重复读）**

也就是说，**只要你不主动设置隔离级别，InnoDB 引擎创建的表使用的就是“可重复读”级别。**

即可重复读，能**防止脏读和不可重复读，并通过间隙锁来避免幻读。**

### 生产环境数据库一般用的什么隔离级别呢？
生产环境大多使用RC。为什么不是RR呢？

可重复读(Repeatable Read)，简称为RR，读已提交(Read Commited)，简称为RC

缘由一：在RR隔离级别下，**存在间隙锁，导致出现死锁的几率比RC大的多！**

缘由二：**在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行!**

也就是说，```RC的并发性高于RR。```

并且大部分场景下，不可重复读问题是可以接受的。毕竟数据都已经提交了，读出来本身就没有太大问题！
