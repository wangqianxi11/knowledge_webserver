## 一、协议格式设计 (Packet Structure)
每个数据包都由协议头和协议体组成。
```plaintext
|----------------------------------------------------------------------------------------------------|
| SESP Packet                                                                                          |
| ---------------------------------------------------------------------------------------------------- |
| Magic Number (2)                                                                                     | Version (1)                               | Flags (1)      | Type (1) | Sequence ID (4) |
| ---------------------------------------------------------------------------------------------------- |
| Length (4)                                                                                           | Reserved (4) / Optional Header Fields ... | Header CRC (2) |
| ---------------------------------------------------------------------------------------------------- |
| Payload (Variable)                                                                                   |
| ---------------------------------------------------------------------------------------------------- |
| Payload CRC (4)                                                                                      |
| ---------------------------------------------------------------------------------------------------- |
```

### 协议头详解 (Header - 固定19字节 + 可选扩展)：


|字段|	长度 (字节)|	说明
|----------------------|-------------------------|----------------|
|Magic Number	|2	|魔数，用于快速识别协议开始，如 0xAE5F。接收方首先检查此字段，用于解决粘包问题。
|Version	|1|	协议版本号 (e.g., 0x01)。用于后续协议升级兼容。
|Flags	|1	|功能标志位，这是协议灵活性的关键。每位代表一个功能：`Bit 0 (LSB)`: CMP：1代表Payload已压缩 Bit 1: ENC：1代表Payload已加密;`Bit 2`: FIN：1代表这是最后一个分片（用于分包）;`Bit 3`: REQ：1代表请求包，0代表响应包;`Bit 4-7`: 保留|
|Type|	1|	包类型，定义Payload的用途。如：心跳(`0x00`)、认证`(`0x01`)、业务数据(`0x02`)、ACK(`0x03`)等。
|Sequence ID|	4|	序列号。用于标识一个完整的消息被分片后的顺序，或用于请求-响应匹配。**解决乱序问题**。
|Length	|4	|整个Packet的长度（包括头+体）。用于从TCP流中解析出一个完整的包，解决粘包问题。
|Reserved|	4|	保留字段，可用于扩展（如时间戳、更长的Optional Headers）。
|Header CRC|	2|	协议头的CRC16校验和。接收方先校验头部的完整性，确保后续解析正确。

### 协议体与尾部 (Payload & Trailer)：

|字段|	长度|	说明|
|----------------|--------------------|-----------------|
|Payload|	变长	|经过压缩和加密处理后的实际业务数据。
|Payload CRC|	4|	整个Payload的CRC32校验和。用于校验应用层数据的完整性。

## 二、三大核心角度实现方案
### 1.压缩 (Compression) - 处理流程：先压缩，后加密
- **策略：选择性压缩**。并非所有数据都适合压缩（如已压缩的视频、图片）。根据数据特征和Flags中的CMP位决定是否压缩。

- 时机：在**加密之前进行压缩**。加密后的数据类似随机数据，压缩率极低。

- 算法选择：

    - 通用场景：LZ4或Snappy。速度极快，CPU开销小，虽压缩率不是最高，但综合效率最佳。

    - 高压缩率场景：zstd。提供从高速到超高压的多级别压缩，非常灵活。

- 流程：

    - 应用层提交原始数据 `original_data`。

    - 检查 `original_data` 是否可压缩（例如，不是音视频等已压缩数据）。

    - 若可压缩，则使用选定算法（如LZ4）进行压缩，得到 `compressed_data`，并设置Flags的`CMP=1`。

    - 若不可压缩，则 `compressed_data = original_data`，设置Flags的`CMP=0`。

### 2.加密 (Encryption) - 处理流程：后加密，再分包
- 目标：提供**保密性（加密）**、**完整性**和**身份验证（HMAC）**。

- 算法选择：

    - 流式加密：`AES-256-GCM` 或 `ChaCha20-Poly1305`。

    - 优势：这两种都是`AEAD`模式，在一次运算中同时完成加密和认证，效率高且安全。GCM是标准，ChaCha20对移动设备CPU更友好。

- 密钥管理：

    - 在通信初期，使用ECDH密钥交换协议，在不安全通道上协商出一个共享密钥。

    - 使用HKDF算法从共享主密钥中衍生出用于加密和认证的会话子密钥。

- 流程：

    - 输入上一步的 `compressed_data`。

    - 生成一个随机Nonce。

    - 使用加密密钥和Nonce，通过AEAD算法加密 compressed_data，得到 cipher_text 和认证标签 auth_tag。

    - 将 auth_tag 附加在 cipher_text 之后，共同组成最终的 `encrypted_payload`。设置Flags的ENC=1。

### 3.分包与组包 (Packetization & Reassembly)
- 原因：应对网络MTU限制，**防止大块数据长时间占用通道**。

- 策略：

    - 发送端：

        - 将处理好的 `encrypted_payload` 按最大分片大小（如 1400字节）进行分片。

        - 为同一个原始消息的所有分片分配相同的 `Sequence ID`。

        - 设置每个分片包的 `Length` 字段。

        - 最后一个分片的Flags设置 `FIN=1`，其余设置 `FIN=0`。

    - 接收端：

        - 根据 `Magic Number` 和 `Length` 从TCP流中读出完整Packet。

        - 校验 `Header CRC` 和 `Payload CRC`。

        - 根据 `Sequence ID` 和 `FIN` 标志将分片缓存起来。

        - 收到 `FIN=1` 的分片后，将所有同 `Sequence ID` 的分片按顺序拼接，还原出完整的 `encrypted_payload`。

        - 然后进行解密 -> 解压缩，得到原始数据。

## 三、完整数据流示例
<b>发送端： 原始数据 -> (可选压缩) -> 加密+认证 -> 分包 + 添加协议头 -> 发送</b>

<b>接收端： 接收 -> 组包 -> 校验协议头 -> 校验载荷CRC -> 解密 -> (可选解压缩) -> 得到原始数据</b>

- 应用层：产生一条 2000字节 的JSON消息 M。

- 压缩层：判断JSON可压缩，使用LZ4压缩为 800字节 的 M_comp。设置 CMP=1。

- 加密层：使用AES-GCM加密 M_comp，得到 816字节 的 M_enc (加密数据+Tag)。设置 ENC=1。

- 分包层：MTU=1500，Payload最大1400字节。M_enc 被分成2包：
```
Packet 1: SeqID=100, FIN=0, Length=1400+19

Packet 2: SeqID=100, FIN=1, Length=416+19
```
- 传输层：发送这两个TCP包。