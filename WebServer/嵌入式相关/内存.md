---
title: 内存
updated: 2025-04-16T20:44:50
created: 2025-04-16T20:13:37
---

## 内存分配方式
**静态存储区**:
在编译前完成，在程序的整个运行期间都存在，例如全局变量、静态变量

**栈**:
函数执行时，函数内的局部变量的存储单元在栈上创建，函数执行结束，自动释放

**堆**:
new开辟的空间
### 堆与栈的区别
**申请方式**
栈的空间由操作系统自动分配/释放，堆上的空间手动分配/释放

**申请大小的限制**
栈空间有限，堆的空间比较灵活

**申请效率**
栈是由自动分配
堆是手动分配，一般速度比较慢，且容易产生内存碎片
### 栈在C语言中的作用
- 栈存储临时变量，包括函数参数和函数内部定义的临时变量，寄存器等
- <b>多线程编程的基础是栈，栈是多线程编程的基石，每一个线程最少有一个属于自己专属的栈</b>，用来存储本线程运行时各个函数的临时变量和函数调用额返回。操作系统基本的功能是支持多线程编程，支持中断和异常处理。
### C++的内存管理
分为代码段、数据段、BSS段、堆区、文件映射区及栈区
**代码段**
- 包括只读存储区和文本区，只读存储区存储字符串常量、文本区存储程序的机器代码

**数据段**
- 存储程序中已初始化的全局变量和静态变量

**BSS段**
- 存储未初始化的全局变量和静态变量，以及所有被初始化为0的全局变量和静态变量

**堆区**
- 调用new/malloc在堆区分配内存，同时需要delete/free释放申请的内存

**映射区**
- 存储动态链接库以及调用mmap函数进行的文件映射

**栈**
- 存储函数的返回地址、参数、局部变量、返回值
### 内存泄漏
申请了一块内存空间，使用完毕后没有释放
### new/delete与malloc/free的区别
在C++中，申请动态内存和释放动态内存，用new/delete 和 malloc/free都可以，new和malloc动态申请的内存都位于堆中，无法被操作系统回收，需要对应的delete/free来释放空间
```c++
void *malloc(int size);
```
说明：malloc向系统申请分配指定size个字节的内存空间返回类型是 `void* `类型,`void*` 表示未确定类型的指针C,C++规定，`void* `类型可以强制转换为任何其它类型的指针

对于类的对象而言，`malloc/free`无法满足动态对象的要求，对象在创建时要自动执行构造函数，在对象消亡之前要自动执行析构函数，而`malloc/free` 不在编译器控制权限之内，无法执行构造函数和析构函数

当然对于没有资源要清理的类，不调用析构函数也没有太大的问题，即使用free或delete没有区别但万一有一些类的成员是指针，而这个指针又在堆上开辟了空间，这时不调用析构函数去释放这个指针指向的这段空间，就会造成内存泄漏，`delete`会调用析构函数，释放指针成员变量的空间，再销毁对象本身的空间；而`free`只释放了对象本身的空间，而指针成员所指向的空间没有被释放

（1）`new` 能够自动计算需要分配的内存空间，而`malloc`需要手工计算字节数

（2) `new`与`delete`带具体类型的指针，`malloc`与`free`返回void类型的指针

（3）`new` 将调用构造函数，而`malloc`不能；`delete`将调用析构函数，而`free`不能

（4）`malloc/free` 需要库文件`<stdlib.h>`支持，而`new/delete`不需要库文件支持

（5）`new`操作可以重载，可以自定义内存分配策略，不做内存分配，或者分配到非内存设备上而`malloc`不能

delete和free被调用后，内存不会不会立即收回，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放啦，还可以做其他用途由于没有对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况，因此，释放完内存后需要将指针向量置为空

