---
title: 归并排序
updated: 2025-05-21T11:31:33
created: 2025-05-21T11:31:02
---

**一、归并排序基本思想（分治 Divide and Conquer）**
1.  **分**：将数组分成两半，递归排序左右两边
2.  **治**：将排好序的两半进行**合并**

**代码：**
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>#include &lt;iostream&gt;</p>
<p>#include &lt;vector&gt;</p>
<p></p>
<p>using namespace std;</p>
<p></p>
<p>// 合并两个有序子数组</p>
<p>void merge(vector&lt;int&gt;&amp; nums, int left, int mid, int right) {</p>
<p>vector&lt;int&gt; temp; // 辅助数组</p>
<p>int i = left, j = mid + 1;</p>
<p></p>
<p>// 归并两个有序区间</p>
<p>while (i &lt;= mid &amp;&amp; j &lt;= right) {</p>
<p>if (nums[i] &lt;= nums[j])</p>
<p>temp.push_back(nums[i++]);</p>
<p>else</p>
<p>temp.push_back(nums[j++]);</p>
<p>}</p>
<p></p>
<p>// 复制剩余元素</p>
<p>while (i &lt;= mid) temp.push_back(nums[i++]);</p>
<p>while (j &lt;= right) temp.push_back(nums[j++]);</p>
<p></p>
<p>// 复制回原数组</p>
<p>for (int k = 0; k &lt; temp.size(); ++k)</p>
<p>nums[left + k] = temp[k];</p>
<p>}</p>
<p></p>
<p>// 归并排序递归函数</p>
<p>void mergeSort(vector&lt;int&gt;&amp; nums, int left, int right) {</p>
<p>if (left &gt;= right) return;</p>
<p></p>
<p>int mid = (left + right) / 2;</p>
<p></p>
<p>mergeSort(nums, left, mid); // 排左半边</p>
<p>mergeSort(nums, mid + 1, right); // 排右半边</p>
<p>merge(nums, left, mid, right); // 合并左右</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

