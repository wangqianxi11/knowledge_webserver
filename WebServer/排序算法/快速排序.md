---
title: 快速排序
updated: 2025-05-21T14:22:14
created: 2025-05-19T20:13:33
---

**一、快速排序基本思想（分治法）**
1.  **选取基准（pivot）**
2.  **分区**：把小于 pivot 的放左边，大于的放右边
3.  **递归**：分别对左右子数组排序

实现：
```c++

#include <iostream>

#include <vector>

using namespace std;

// Hoare 分区函数（使用 do...while）

int hoarePartition(vector<int>& arr, int low, int high) {

    int pivot = arr[low]; // 选最左边作为 pivot

    int i = low - 1;

    int j = high + 1;

    while (true) {

    do {

        i++;

    } while (arr[i] < pivot); // 从左往右找 ≥ pivot 的元素

    do {

        j--;

    } while (arr[j] > pivot); // 从右往左找 ≤ pivot 的元素

    if (i >= j)

        return j; // i 和 j 交错，返回分区点

        swap(arr[i], arr[j]); // 交换 arr[i] 和 arr[j]

    }

}

    // 快速排序（基于 Hoare 分区）

    void quickSort(vector<int>& arr, int low, int high) {

    if (low < high) {

        int p = hoarePartition(arr, low, high);

        quickSort(arr, low, p); // 注意：递归到 p，而不是 p-1

        quickSort(arr, p + 1, high);

    }

}
```
快速排序是**不稳定排序**，所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 O(n²)，它的平均时间复杂度为 O(n log n)。