---
title: 日志系统
updated: 2025-06-15T16:09:52
created: 2025-04-29T15:50:04
---

## 运行机制

使用`单例模式`创建日志系统，使用异步写入方式。
将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容 push 进队列，写线程从队列中取出内容，写入日志文件

## 生产者消费者模型

通过**缓冲区**将生产者和消费者解耦的设计模式。生产者线程负责生成数据，消费者线程负责消费数据。缓冲区的存在可以独立运行

#### 关键

1.  **线程安全的缓冲区**：
2.  **同步机制**：
3.  **数据流处理**：
    **使用 std::condition_variable 解决同步问题**：
    在 C++中，std::condition_variable 是一种条件变量，它可以用来实现线程之间的等待与通知机制。结合 std::mutex（互斥锁），它可以用于解决生产者-消费者之间的同步问题。

- 等待 (wait)：线程可以使用条件变量的 wait 方法，阻塞自己直到条件满足。
- 通知 (notify_one 和 notify_all)：当某个条件满足时，可以使用 notify_one 唤醒一个等待的线程，或使用 notify_all 唤醒所有等待线程。

### 使用 std::mutex 解决资源竞争问题：
  在多线程环境下，多个线程同时访问共享资源时，会产生数据竞争问题。为了解决这个问题，需要使用 std::mutex 来确保每次只有一个线程能够访问共享的缓冲区。

### 优化与扩展

1.  多生产者-多消费者
2.  **性能优化**：

- 无锁队列：降低锁竞争
- 自旋锁：减少线程上下文切换开销

## 为什么使用异步？

为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区 push 消息，消费者线程从缓冲区 pop 消息

阻塞队列将生产者-消费者模型封装，使用循环数组实现队列，作为两者共享的缓冲区

异步日志将所写的日志内容存入阻塞队列，写线程从阻塞队列中取出内容，吸入日志
**可以提高系统的并发性能**

同步日志涉及到 I/O 操作，当单条日志比较大的时候，会阻塞整个处理流程，并发能力下降。

## 设计模式

**单例模式**：只允许一个实例的存在，并提供一个访问的全局访问点

**优点**

- 保证内存中只有一个实例，减少内存的开销
- 避免对资源的多重占用
- 设计全局访问点，优化共享资源的访问

**缺点**
- 一般没有接口，不能继承，扩展困难，违背开闭原则
- 并发测试中，不利于调试，单例中的代码没有执行完，也不能模拟生成一个新的对象
- 容易违背单一职责原则

**实现步骤**

1.  私有化构造函数：只能通过该类提供的静态方法得到唯一实例
2.  局部静态变量：利用只初始化一次的特点，返回静态成员变量。

### 懒汉式：获取该类对象时创建该类的实例

```c++
class single{
private:
  single(){} // 私有化构造函数
  ~single(){}
public:
// 公有静态方法获取实例
  static single* getinstance();
};

single* single::getinstance(){
  static single obj;
  return &amp;obj;
}
```

### 饿汉式：获取该类对象之前已经创建好该类的实例

```c++
class single{
private:
  static single* p;
  single(){}
  ~single(){}
public:
  static single* getinstance();
};

single* single::p = new single();
single* single::getinstance(){
  return p;
}
```
