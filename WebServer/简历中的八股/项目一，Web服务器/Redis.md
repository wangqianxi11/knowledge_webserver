---
title: Redis
updated: 2025-06-17T15:24:25
created: 2025-06-15T16:32:50
---

### Redis 在你这个系统中起到什么作用？

**答：** Redis 是我系统中承担**高频访问、临时性数据管理**的核心组件，作用包括：
| **功能模块** | **Redis 作用** |
|--------------|----------------------------------------|
| 登录认证 | 存储用户登录后的 token（session 管理） |

**Session 和 Cookie 的区别**

Session 和 Cookie 都是用于在 Web 开发中维护用户状态的机制，但它们有以下主要区别：

**存储位置**

- Cookie：存储在客户端（用户的浏览器中）
- Session：存储在服务器端（通常存储在内存、文件或数据库中）
  **安全性**
- Cookie：相对不安全，因为用户可以查看和修改
- Session：更安全，敏感数据保存在服务器端
  **存储容量**
- Cookie：单个 Cookie 通常限制为 4KB，每个域名下的 Cookie 数量也有限制
- Session：理论上只受服务器内存限制，可以存储更多数据
  **生命周期**
- Cookie：可以设置过期时间（持久性 Cookie），也可以设置为浏览器关闭时失效（会话 Cookie）
- Session：通常当用户关闭浏览器或一段时间不活动后失效（具体时间由服务器配置决定）
  **实现方式**
- Cookie：通过 HTTP 头部==Set-Cookie==和==Cookie==实现
- Session：通常依赖 Cookie（使用 Session ID）或 URL 重写来跟踪会话
  **性能影响**
- Cookie：每次请求都会自动发送，可能增加网络流量
- Session：服务器需要查找和加载会话数据，可能增加服务器负担
  **典型使用场景**
- Cookie：记住登录状态、用户偏好设置、跟踪用户行为等
- Session：存储购物车内容、临时表单数据、敏感的用户会话信息等
  在实际应用中，Session 通常会使用 Cookie 来存储 Session ID，而实际的会话数据则保存在服务器端。

### Session 是怎么设计的？用 Redis 实现 Token 登录的流程？

**答：**

我采用**Token-based 认证机制**配合 Redis 实现无状态登录。

**流程设计如下：**

- 用户登录成功后，系统生成一个唯一 Token（如 UUID + 随机盐）；
- Token 存入 Redis：  
  setex session:{token} {ttl} {user_id}
  - 如：setex session:abc123 3600 42，有效期 1 小时；
- 客户端后续请求（上传、下载）附带 Token；
- 服务端校验 Redis 是否存在该 Token，取出 user_id，完成授权；
  **优点：**
- Redis 高速读写，适合频繁 token 验证；
- 自动过期，降低内存使用；
- 服务端无状态，适合分布式部署。

### Redis 数据结构有哪些？你用到了哪些？

**答：** Redis 支持多种数据结构，我系统中用到了以下几种：
| **类型** | **用法** |
|----|----|
| String | 存储 session（token → user_id）、文件 offset、限流计数器 |
| Set | 存储已上传文件 MD5 集合（快速去重） |
| Hash | 存储每个文件上传状态，如 upload:file123 =\> {offset: 123, status: uploading} |
| List / Stream（可选） | 日志记录、异步任务通知 |

### 上传过程中 Redis 会不会成为瓶颈？如何优化？

**答：** 理论上 Redis 非常快（内存读写、单线程），但在以下场景下可能成为瓶颈：

**可能瓶颈：**

- 高并发下频繁读写 offset（断点续传）
- Token 校验请求太多
- 使用过多复杂命令或大键值结构
  **优化策略：**
- **开启 Redis 的持久连接池**，减少 TCP 握手；
- **避免使用大 Key / 热 Key**，拆分如 upload:{md5}:{uid}；
- **批量操作**：用 pipeline 或合并操作减少 RTT；
- **异步更新**：offset 实时写本地缓存，定期同步 Redis；
- **水平扩展**：用 Redis Cluster 分片扩容；
- **限频数据移出 Redis**：某些冷数据写入数据库或落盘。

### 如何保证 Redis 中的数据一致性（如断点续传偏移）？

**答：**

**核心原则：以 Redis 为真实上传状态源，确保其和文件写入同步更新**

**实现措施：**

- **写入文件后立刻更新 offset 到 Redis**（确保数据落盘）；
- 每次断点续传前读取 upload:{file_md5}:offset；
- 上传过程中用 Lua 脚本实现原子检查+更新 offset，防止并发写错；
- 若 Redis 挂掉，可在文件系统中查找 .tmp 文件大小做近似恢复（容错机制）；
- 上传完成后，Redis offset 键删除或标记完成状态。

### Redis 的持久化机制是啥？为什么适合做 session 缓存？

| **机制**        | **简介**                        | **特点**                     |
| --------------- | ------------------------------- | ---------------------------- |
| RDB（快照）     | 定时将内存数据保存为 .rdb 文件  | 启动快，占用小，不适合频繁写 |
| AOF（追加日志） | 每个写操作追加日志，重启回放    | 持久化强，但体积大、重启慢   |
| 混合模式        | Redis 7 默认，结合 RDB+AOF 优点 | 平衡性能与可靠性             |

**为什么适合存 session？**

- 登录 token 是**频繁读取，偶尔写入**的典型缓存场景；
- Redis 支持设置自动过期，session 可自动清理；
- 就算 Redis 重启丢失，客户端下次访问可强制重新登录（容错性好）；
- 支持高并发、低延迟，用户体验好。
