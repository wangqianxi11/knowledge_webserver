---
title: I/O多路复用
updated: 2025-08-24T11:08:08
created: 2025-04-28T09:38:05
---

### 什么是 IO 多路复用

1.  **一种在单个线程中管理多个输入/输出通道**的技术，允许一个线程同时监听多个输入流（例如网络套接字、文件描述符），在有数据可读或可写进行相应的处理
2.  常见的 IO 多路复用机制包括 select、poll 和 epoll，这些机制将多个 IO 注册到一个事件管理器中，通过阻塞方式等待事件的发生。一旦有事件发生，线程被唤醒
3.  IO 多路复用的优点是可以有效的管理大量的 IO 通道，减少线程的创建和销毁开销，提高系统的并发能力

### IO 多路复用的优缺点

优点

- 高效：`单个线程管理多个 IO 通道`，减少了线程的创建和销毁，提高并发能力
- 资源节约：相比每个通道创建独立的线程，使用更少的线程处理大量的 IO 通道，节约了系统资源
- 简化编程模型：将异步的 IO 操作转换为同步的事件驱动模型，简化了编程逻辑和代码复杂度
- 可扩展性：可以轻松扩展到更多的 IO 通道
  缺点
- 不适用于 CPU 密集型任务：**IO 多路复用适用于 IO 密集型任务**，对于 CPU 密集型任务，使用多线程或多进程模型可能更为合适

### 应用场景

1.  网络编程：使用 IO 多路复用可以轻松管理多个网络套接字，监听并处理可读或可写事件
2.  高性能服务器：需要处理大量并发连接的服务器，提高服务器的吞吐量和响应速度
3.  文件操作：
4.  定时器和事件调度：通过将定时器和事件的触发时间注册 IO 多路复用机制中，可以在特定的时间点触发相应的事件

### 原理

1.  多路复用：通过一个线程同时监听多个 IO 事件的就绪状态。在传统的阻塞 IO 模型中，每个 IO 操作都需要一个独立的线程来处理，当有大量的 IO 操作时，带来线程切换和上下文切换的开销。多路复用使用一个线程来监听多个 IO 事件，避免了线程数量的增加，减少开销
2.  IO 事件就绪通知：通过**操作系统**提供的**系统调用（select、poll、epoll 等）**来监听多个 IO 事件的就绪状态
3.  非阻塞 IO：当一个 IO 操作无法立即完成时，不会阻塞线程，而是立即返回一个错误码或者特定的状态，应用程序可以继续处理其他 IO 操作，提高系统的并发性能
4.  事件循环：通过事件循环来处理就绪的 IO 事件，事件循环不断监听 IO 事件的就绪状态，有 IO 事件就绪时，会调用相应的回调函数处理

### 实现

1.  select：最古老，使用一个**文件描述符集合**来监听多个 IO 事件的就绪状态。应用程序需要将监听的文件描述符添加到集合中，调用 select 函数进行监听。当有文件描述符就绪时，select 函数会返回，并告知哪些文件描述符已经就绪，应用程序可以通过**遍历文件描述符集合**来处理就绪的 IO 事件
2.  poll：select 的改进。与 select 不同，poll 不需要每次调用都将文件描述符集合传递给内核，而是使用一个 pollfd 结构体传递。应用程序将需要监听的文件描述符和事件类型添加到 pollfd 中，调用 poll 函数监听。通过遍历**pollfd 结构体数组**来处理就绪的 IO 事件
3.  epoll：Linux 特有的，使用一个**内核事件表**来管理和监听多个 IO 事件的就绪状态。应用程序将需要监听的文件描述符添加到内核事件表中，调用 epoll_wait 函数监听。与 select 和 poll 不同，epoll 使用回调函数处理就绪的 IO 事件，不需要遍历事件列表

**注：select、poll 和 epoll 都是同步 IO**

### select 和 poll 的缺点

- 每轮循环都需要从用户空间向内核空间拷贝
- 内核轮询，检测每个文件描述符有没有就绪事件
- IO 返回后，遍历每个文件描述符找到就绪事件的文件描述符

#### select 函数（适用于连接数较小（fd\<1024),跨平台开发的一些简单场景)

​select​ 使用 <strong style="color:red">​fd_set​ 结构来管理文件描述符集合</strong>，

底层依赖于一个**固定大小的位图结构**来标记和跟踪每个文件描述符的状态。

Linux 中默认定义如下：

> #define FD_SETSIZE 1024
> 意味着，**限制来源于头文件定义，不是内核限制。**

```c++
int select(
intmax_fd,
fd_set*readset,
fd_set*writeset,
fd_set*exceptset,
struct timeval*timeout
)
```

#### poll 函数

poll 函数使用**pollfd 结构体数组**存储文件描述符信息。

当调用 poll 时：

1.  用户空间到内核空间拷贝：
    - 整个 pollfd 数组从用户空间拷贝到内核空间
    - 内核会遍历检查每个文件描述符的状态
2.  结果返回： - 内核将就绪的事件填充到 revents 字段 - 修改后的数组从内核空间拷贝到用户空间

```c++
struct pollfd{
int fd;//需要监视的文件描述符
short events;//需要内核监视的事件
short revents;//实际发生的事件
};

//API
intpoll(structpollfdfds[],nfds_tnfds,inttimeout);
```

#### epoll 函数

epoll 的**内核事件表**是与 select/poll 机制最本质的区别。

内核事件表是 epoll 在内核空间维护的一个数据结构，存储了所有被监控的文件描述符及其关注的事件：

- 不像 select/poll 每次调用都要重新传入所有监控的 fd
- 使用红黑树等高效数据结构
- **事件驱动，只返回就绪的事件，无需遍历所有监控的 fd**
  epoll 的内核事件表包括一个 **红黑树（管理所有监听 FD）** 和一个 **就绪事件链表（存放活跃事件）**

##### 内核事件表的工作原理

1.  创建阶段--​epoll_create

```c++
int epoll_fd = epoll_create(0);
```

- **创建一个 epoll 实例，内核会为该实例分配一个事件表**

2.  维护阶段--epoll_ctl​

```c++
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &event);
```

- 当添加一个 fd 时，内核会：
  - 在事件表中创建或更新一个条目
  - 将该 fd 与对应的事件回调函数关联
  - 设置回调机制，当 fd 状态变化时自动触发

3.  就绪队列机制

- 内核为每个 epoll 实例维护一个就绪队列
- 当监控的 fd 状态变化时，内核会：
  - 通过回调函数立即感知变化
  - 将就绪的 fd 事件加入就绪列表
  - 唤醒可能阻塞的 epoll_wait 调用、

##### 内核事件表的底层实现

1.  **红黑树**
    - **存储所有被监控的 fd**
    - **保证插入、删除、查找操作都是 o(log n)事件复杂度**
    - **键是被监控的 fd，值是对应的 epitem 结构**
2.  **就绪链表**
    - **存储所有就绪的事件**
    - **epoll_wait 直接从该链表获取结果，无需扫描所有 fd**
3.  **epitem 结构**

```c++
    struct epitem {
    struct rb_node rbn; _// 红黑树节点_
    struct list_head rdllink; _// 就绪链表节点_
    struct epoll_filefd ffd; _// 文件描述符信息_
    struct eventpoll \*ep; _// 所属的 epoll 实例_
    struct epoll_event event; _// 监控的事件设置_
    };
```

### 边沿触发和水平触发

### 水平触发（Level Triggered, LT） 和 边沿触发（Edge Triggered, ET） 是 I/O 多路复用中用于描述事件通知机制的两种模式

#### 水平触发

只要文件描述符关联的读内核缓冲区非空，就一直发出可读信号

只要文件描述符关联的内核写缓冲区，有空间可以写入，就一直发出可写信号

支持**阻塞和非阻塞**两种方式

#### 边沿触发

当文件描述符关联的读内核缓冲区转化为非空的时候，发出可读通知

当文件描述符关联的内核写缓冲区由满转为不满的时候，发出可写通知

区别在于**边沿触发只在变化的时候通知一次**

此外，边沿触发需要一次性的把缓冲区的数据读完为止，即一直读，直到读到 EGAIN 为止，需要**设置非阻塞**

**注意**：

- **select 和 poll 只支持水平触发**
- epoll 同时支持水平和边缘触发
- **收到信号通知后，如果读缓冲区已经读取了还剩余数据，水平触发会再次通知，而边缘触发不会**

### epoll 调用的基本流程

```c++
int epfd = epoll_create(); // 创建 epoll 实例</p>
epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event); // 注册事件</p>
int n = epoll_wait(epfd, events, maxevents, -1); // 等待事件</p></th>
```

| **操作**                   | **属于**                    | **描述**                                         |
| -------------------------- | --------------------------- | ------------------------------------------------ |
| epoll_create               | 用户态 → 内核态             | 创建 epoll 实例，返回一个 fd（进入内核分配资源） |
| epoll_ctl（注册/删除事件） | 用户态 → 内核态             | 需要进入内核将事件信息挂到某个 fd 的等待队列上   |
| **epoll_wait**             | ✅ 内核态阻塞（直到有事件） | 系统调用，**在内核中阻塞/轮询**直到有事件发生    |
| 返回到 epoll_wait 用户态后 | 用户态                      | 用户遍历 events\[i\] 做业务处理                  |
| 应用层读/写数据            | 用户态 → 内核态             | read()/write() 触发系统调用（也会陷入内核）      |

在 epoll 中，**事件注册和监听是通过系统调用进入内核态完成的，而事件处理和业务逻辑运行在用户态。**

epoll_wait() 是 epoll 最关键的内核态阻塞调用，一旦有事件发生，它将返回用户态处理。

### 同步和异步

- **同步**：执行一个操作时，在没有得到结果之前，该调用就不返回或继续执行后续操作。简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。
- **异步**：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出之后，被调用者通过“状态”、“通知”、“回调”三种途径通知调用者。

### 阻塞和非阻塞

- **阻塞**：进程给 CPU 传达一个任务之后，一直等待 CPU 处理完成，然后才执行后面的操作。阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
- **非阻塞**：进程给 CPU 传达任务后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程[<sup>3</sup>](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fm0_37806112%2Farticle%2Fdetails%2F81910410)。
  **总结来说，同步和异步关注的是消息通知的机制，而阻塞和非阻塞关注的是程序在等待消息通知时的状态。**
