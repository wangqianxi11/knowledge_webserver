---
title: 数据库
updated: 2025-06-15T16:32:01
created: 2025-05-08T17:19:55
---


## 一、为什么使用 RAII 管理数据库连接？

**1. 自动释放资源，避免泄漏**
数据库连接是一种昂贵的资源，如果使用后没有手动释放（归还给连接池），将导致连接耗尽。RAII 通过对象生命周期自动释放资源，不依赖程序员手动 release()。

**2. 异常安全**
如果中途抛出异常，比如 SQL 查询异常，手动释放连接的代码可能不会执行。而 RAII 的析构函数会自动被调用，确保资源释放。

**3. 逻辑清晰，易于维护**
RAII 模板将“获取”和“释放”操作封装在一个类中，调用者只需获取连接，其他交由类本身管理，提高代码可读性和稳定性。

## 常见数据库类型及适用场景

| **游戏类型** | **推荐数据库架构**                |
| ------------ | --------------------------------- |
| 小型游戏     | SQLite / Firebase / MySQL         |
| 中型网游     | MySQL + Redis                     |
| 大型 MMO     | MySQL + Redis + MongoDB（混合）   |
| 社交类游戏   | MySQL + Redis + 图数据库（Neo4j） |

## Mysql 主要存哪些信息，表结构如何设计？

主要用来存储持久化的文件元数据，包括用户 user 表和 files 表，其中 files 表依赖于 user 表。

### 如何防止重复上传？（尚未实现）

上传前计算文件 MD5，上传前在 Redis 中查询是否已有记录；上传完成后将 MD5 写入 MySQL 建立唯一索引或唯一约束。
我们使用 **文件内容的唯一标识（如 MD5 或 SHA256 哈希）** 作为去重依据。

**实现流程：**

1.  客户端上传前先计算文件的 MD5 哈希；
2.  上传前通过 Redis 或 MySQL 查询该 MD5 是否已存在；
3.  如果已存在：
    - 可提示用户“文件已上传”；
    - 或直接复用已有文件路径，写入一条逻辑引用记录；
4.  若不存在，再继续上传。

## 多用户同时上传时，MySQL 如何避免写冲突？

**标准回答：**
使用数据库层面的**唯一约束 + 乐观锁**机制来避免并发写入冲突。
**核心策略：**

1.  **唯一约束**：对 md5 字段设置 UNIQUE KEY，即使多个用户并发写入相同文件，也只有一个能成功；
2.  **错误处理**：程序捕获 Duplicate entry 异常，说明其他人已上传成功，转而使用已有记录；
3.  **乐观锁（可选）**：如果涉及同一文件的元数据修改（如引用数），可使用版本号字段配合 WHERE version = ? 进行原子更新；
4.  **事务封装**：整个写入过程应封装在事务中，确保原子性。

## 如何设计文件版本控制系统（如同名文件）？

**目标：允许同名文件多版本共存，并支持回滚、预览历史等功能。**
**实现思路：**

**方案 1：基于版本号（Versioning）**

- 每个用户上传文件时，如果文件名重复，自动分配 version = last_version + 1；
- 数据库设计：

```sql
CREATE TABLE file_versions (
id INT AUTO_INCREMENT PRIMARY KEY,
filename VARCHAR(255),
version INT,
uploader_id INT,
md5 CHAR(32),
upload_time DATETIME,
filepath VARCHAR(512),
INDEX(filename, uploader_id, version)
);
```

**方案 2：基于路径重命名策略**

- 若用户上传了重复文件名，服务端自动加后缀，例如：  
  report.pdf  
  report(1).pdf  
  report(2).pdf
- 实现方式：
  - 查询该用户历史上传记录中是否有同名；
  - 若有，自动追加版本号或时间戳。

**方案 3：混合型：逻辑版本 + 物理路径分离**
- 文件内容存储使用 MD5 为目录或文件名；
- 展示逻辑中保留原始文件名 + 版本号；
- 有效地实现了 **存储去重 + 用户体验保留**。

## 为什么不把文件存入 Mysql？

**1. MySQL 不适合大对象（BLOB）存储**

- MySQL 虽然支持 BLOB/LONGBLOB 类型，但它是**将整个文件内容作为二进制存入数据页**；
- 导致：
  - 数据库体积迅速膨胀；
  - 缓存命中率下降（影响其他热数据）；
  - 查询和写入变慢，甚至引发锁竞争；
  - 数据页碎片多，难以管理。
  
**2. I/O 效率差，易造成性能瓶颈**
- 文件读写本质是大块顺序 I/O，数据库擅长处理的是**小块随机 I/O（行级操作）**；
- 写入/读取大文件会拖慢整个数据库的事务处理能力；
- 备份、恢复、复制（主从）也会非常慢。
  
**3. 数据库资源宝贵，应专注管理结构化数据**
- 存储文件这种**非结构化数据**本就不是关系型数据库的职责；
- 应该将数据库用于：
  - 存储文件的元数据（文件名、大小、MD5、路径、上传人等）；
  - 维持一致性、查询效率和索引优化。

**4. 文件存磁盘或对象存储更合适**
- 本地磁盘 + 分层目录结构可高效管理大量文件；
- 或者使用对象存储（如 MinIO、S3），具备：
  - 高可用性、可扩展性；
  - 支持 CDN 分发；
  - REST API 上传下载。

## 上传完后怎么保证 MySQL 和文件状态一致？

**1. 明确“两步操作”的风险点**
文件上传流程可以分为两步：

1.  写入文件系统（磁盘或对象存储）
2.  写入 MySQL（存储文件元数据）
    
**2. 核心原则：只有在文件上传成功后再写入数据库，并加上状态字段管理流程**

**推荐方案：“状态标记 +原子写入 +异常回滚机制”**
    
**步骤设计：**
3.  文件分块上传并保存为 .tmp 或 .part 文件
   
4.  所有块上传完毕 → **校验 MD5**
   
5.  校验通过 → 将临时文件 **rename** 为最终文件
   
6.  最后一步：**插入 MySQL** 并将文件状态标记为 complete
   
7.  出现异常 → 删除临时文件 / 回滚数据库记录

# 场景题

## 1.当前有一个数据库，设计一个连接池，可以管理客户端连接实现复用，同时对长时间未响应的连接进行关闭，怎么设计

- **核心组件**：
  - 连接池管理
    - 初始化、管理和销毁连接池
    - 维护活跃连接和空闲连接
    - 处理连接请求和释放
  - 连接对象
    - 记录连接状态
    - 实际的连接
    - 记录最后使用时间
  - 监控线程
    - 定期检查连接状态
    - 关闭长时间未响应的连接
    - 维护连接池大小

## 2.怎么判断连接是否活跃

1.  **连接状态检查**
2.  **最后活动时间检查**

## 3. 怎么设计连接保活

- 大多数数据库服务器会主动关闭长时间空闲的连接以释放资源
- 确保应用层与数据库服务器对连接状态的认知一致
  **原理：**

1.  TCP 层保活原理
    - keppalive 机制：
      - 操作系统级别的 TCP 保活包
      - 但间隔时间长，不适用于数据库连接
2.  应用层保活原理
    - **心跳机制**;
      - 定期发送小型查询，维持应用层活跃
    - 主动保活：定期主动发送保活查询
    - 被动检测：使用前验证连接有效性

## 设计一个 Mysql 表，让每一个用户只能访问到自己上传的东西，其他用户不可访问

需要从表结构设计和权限控制逻辑两方面入手：

### 表结构设计

```sql
CREATE TABLE user_files (
id INT AUTO_INCREMENT PRIMARY KEY,
user_id INT NOT NULL, -- 文件归属用户
file_name VARCHAR(255) NOT NULL, -- 文件名或路径
file_path TEXT, -- 文件存储位置
upload_time DATETIME DEFAULT NOW(), -- 上传时间
-- 其他元数据，如文件大小、类型等
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### 权限控制策略

**Mysql 本身不支持行级权限**（即不能让某个用户仅访问表中的部分行）
**必须在应用层实现基于 user_id 的权限控制**

1.  **上传文件时绑定用户**
2.  **下载、查看、删除时必须验证所属权**

## 如果 A 表有 100 万数据，B 表有 1000 万数据，如何优化提高查询效率

### 查询瓶颈

- 缺乏索引
- 关联字段类型不匹配或未索引
- 连接方式不合理

### 优化方案

| **优化项**             | **说明**                                                   |
| ---------------------- | ---------------------------------------------------------- |
| ✅ 建立适当索引         | 特别是用于 JOIN、WHERE、ORDER BY 的字段                    |
| ✅ 减少 JOIN 数据量     | 用子查询/筛选/分页等方式控制参与 JOIN 的记录数             |
| ✅ 选择合适的 JOIN 顺序 | 大表尽量作为驱动表的被连接方（被动方）                     |
| ✅ 覆盖索引             | 尽量让查询字段都包含在索引中，避免回表                     |
| ✅ 只查必要字段         | 避免 SELECT \*                                             |
| ✅ 分页或分批查询       | 避免一次查询太多数据                                       |
| ✅ 查询计划分析         | 使用 EXPLAIN 查看是否使用索引、Join 类型是否为 Nested Loop |
