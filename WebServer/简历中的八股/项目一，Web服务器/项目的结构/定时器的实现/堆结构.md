---
title: 堆结构
updated: 2025-04-07T14:58:05
created: 2025-04-07T11:27:36
---

**堆：用数组实现的完全二叉树，根据数组的下标进行堆构建**
- **父节点：i，左子节点：2\*i+1，右子节点：2\*i+2**
分类：
1、大根堆：根节点是整棵树最大的数据，每个节点的数据都比子节点大
2、小根堆：根节点是最小的数，每个节点的数据都比子节点小
注：堆的根节点中存放的是最大或者最小元素，其他节点的排序顺序是未知的。在一个最大堆中，最大的元素总是位于index0的位置，但是最小的元素则未必是最后一个元素
一、堆的构建（以小根堆为例）
从末尾节点的父节点的这棵树开始，越小的数据往上移动，子节点也需要调整，递归调整。
![image1](../../../resources/98c19c2ec0514997b29634ed92885175.png)
![image2](../../../resources/86ff7e5fa92844b3aa256c8e9c08760c.png)

![image3](../../../resources/024026322753470bbebde16c84713ca8.png)

![image4](../../../resources/905630a2bd5c40e08b5b45ff48ada214.png)

2和3交换后，需要检验3所在的树是否也符合小根堆的性质。
![image5](../../../resources/930f60589ae54f1bb506690fb1665716.png)

1和9交换后，9所处的节点具有子节点，递归调整9所处的树
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p></th>
<th><p>private List&lt;Integer&gt; arr;</p>
<p>/**</p>
<p>* 构建最小堆，从最后一个节点的父节点开始调整（也可以对数组中某段连续数据即下标从firstIndex -&gt; endIndex进行建堆）</p>
<p>* @param firstIndex 起始下标</p>
<p>* @param enIndex 结束下标</p>
<p>*/</p>
<p>public void buildMinHeap(int firstIndex,int enIndex) {</p>
<p>for (int i = enIndex/2; i &gt;= firstIndex; i--) {</p>
<p>adjustDown(i,enIndex);</p>
<p>}</p>
<p>}</p>
<p>/**</p>
<p>* 调整当前子树，越小的数据往上移动，注意调整的该节点还有子节点的情况，所以需要递归调整。</p>
<p>* @param parentIndex 父节点的下标</p>
<p>*/</p>
<p>private void adjustDown(int parentIndex,int endIndex) {</p>
<p>int left = 2 * parentIndex + 1;</p>
<p>int right = 2 * parentIndex + 2;</p>
<p>//最小值的下标</p>
<p>int minIndex = parentIndex;</p>
<p>if (left &lt; endIndex &amp;&amp; arr.get(left) &lt; arr.get(minIndex)) {</p>
<p>minIndex = left;</p>
<p>}</p>
<p>if (right &lt; endIndex &amp;&amp; arr.get(right) &lt; arr.get(minIndex)) {</p>
<p>minIndex = right;</p>
<p>}</p>
<p>if(minIndex == parentIndex){</p>
<p>return;</p>
<p>}</p>
<p>//交换元素</p>
<p>swap(parentIndex,minIndex);</p>
<p>//递归调整</p>
<p>adjustDown(minIndex,endIndex);</p>
<p>}</p>
<p>private void swap(int parentIndex,int minIndex){</p>
<p>int temp = arr.get(parentIndex);</p>
<p>arr.set(parentIndex,arr.get(minIndex));</p>
<p>arr.set(minIndex,temp);</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

二、插入
新增元素首先插在堆的末尾元素，依据小根堆的性质，自底向上，递归调整。
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p></th>
<th><p>/**</p>
<p>* @param item 要插入的元素</p>
<p>*/</p>
<p>public void insertToMinHeap(int item){</p>
<p>arr.add(item);</p>
<p>//根节点</p>
<p>if(arr.size() == 1){</p>
<p>return;</p>
<p>}</p>
<p>adjustUp(arr.size()-1);</p>
<p></p>
<p>}</p>
<p></p>
<p>/**</p>
<p>* 向上调整</p>
<p>* @param childIndex 要往上调整的子节点的下标</p>
<p>*/</p>
<p>private void adjustUp(int childIndex){</p>
<p>int parentIndex = (childIndex - 1)/2;</p>
<p>int parentItem = arr.get(parentIndex);</p>
<p>int childItem = arr.get(childIndex);</p>
<p></p>
<p>if(parentItem &gt; childItem){</p>
<p>swap(parentIndex,childIndex);</p>
<p>adjustUp(parentIndex);</p>
<p>}</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
三、堆删除
对于最大堆和最小堆，删除是针对堆顶元素，即把末尾元素移动到堆顶，再自顶向下。
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p></th>
<th><p>public int deleteMinHeap(){</p>
<p>//取出最小元素，并将最后一个元素置顶</p>
<p>int minItem = arr.get(0);</p>
<p>arr.set(0,arr.get(arr.size()-1));</p>
<p>//移除末尾元素</p>
<p>if(arr.size() &gt; 1){</p>
<p>arr.remove(arr.size() - 1);</p>
<p>}</p>
<p>//向下调整堆(该实现见上面)</p>
<p>adjustDown(0,arr.size()-1);</p>
<p>return minItem;</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
堆和二叉排序树的区别：
内存占用：二叉排序树占用的内存空间更大，需要分配额外的内存来存储指针指向其左右子节点。堆结构根据数组下标来执行左右子节点
节点的排序：二叉排序树中，左节点必须比父节点小，右节点必须比父节点大。小根堆结构中两个节点都必须比父节点小，并且左右子节点的数据大小是不确定的。
搜索性能：二叉搜索树是为了动态查找而设计的数据结构，是面向查找操作的，再二叉排序树中查找一个节点的平均时间复杂度是O(logn)；在堆中搜索并不是第一优先级，堆是为了实现排序的数据结构。

