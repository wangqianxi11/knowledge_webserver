---
title: 阻塞双端队列
updated: 2025-04-07T16:31:44
created: 2025-04-07T16:01:03
---

C++类模板：编译器从类模板可以自动生成多个类。
C++类模板的写法如下：
```c++
template <类型参数表>

class 类模板名{

    成员函数和成员变量

};
```
类模板的成员函数放到类模板定义外面的语法：
```c++
template <类型参数表>

返回值类型 类模板名<类型参数名列表>::成员函数名(参数表)

{

...

}
```
用类模板定义对象的写法如下：
| 1   | 类模板名\<真实类型参数表\> 对象名(构造函数实际参数表); |
|-----|--------------------------------------------------------|

阻塞双端队列模板类，用于多线程环境下的生产者-消费者场景
```c++
template<class T>

class BlockDeque {

public:

    explicit BlockDeque(size_t MaxCapacity = 1000);

    ~BlockDeque();

    void clear();

    bool empty();

    bool full();

    void Close();

    size_t size();

    size_t capacity();

    T front();

    T back();

    void push_back(const T &item);

    void push_front(const T &item);

    bool pop(T &item);

    bool pop(T &item, int timeout);

    void flush();

private:

    std::deque<T> deq_;

    size_t capacity_;

    std::mutex mtx_;

    bool isClose_;

    std::condition_variable condConsumer_;

    std::condition_variable condProducer_;

};
```

## 构造函数和析构函数
```c++
template<class T>

BlockDeque<T>::BlockDeque(size_t MaxCapacity) :capacity_(MaxCapacity) {

    // 构造函数

    isClose_ = false;

}

template<class T>

BlockDeque<T>::~BlockDeque() {

    // 析构函数

    Close();

};
```

## Close()函数关闭阻塞双端队列**
```c++
template<class T>

void BlockDeque<T>::Close() {

{ // 作用域开始

std::lock_guard<std::mutex> locker(mtx_); // 加锁，确保线程安全

deq_.clear(); // 清空队列

isClose_ = true; // 关闭标志

} // 作用域结束

condProducer_.notify_all(); // 唤醒所有等待的生产者线程

condConsumer_.notify_all(); // 唤醒所有的消费者线程

};
```

## 向队列尾部添加元素
```c++
template<class T>

void BlockDeque<T>::push_back(const T &item) {

    // 向双端队列尾部添加

    std::unique_lock<std::mutex> locker(mtx_); // 互斥锁保护共享数据

    // 检查队列是否已满

    while(deq_.size() >= capacity_) {

        condProducer_.wait(locker); // 释放锁并等待

    }

    // 添加

    deq_.push_back(item);

    condConsumer_.notify_one(); // 唤醒一个消费者线程

}
```

## 从队列头部取出元素，并且允许消费者在指定时间等待元素
```c++
template<class T>

bool BlockDeque<T>::pop(T &item, int timeout) {

    // 带超时功能的pop方法，运行消费者在指定时间内等待元素

    std::unique_lock<std::mutex> locker(mtx_);

    while(deq_.empty()){

    // 带超时的等待

    if(condConsumer_.wait_for(locker, std::chrono::seconds(timeout))

    == std::cv_status::timeout){

        return false; //超时即返回

    }

    if(isClose_){

        eturn false;

    }

    }

    item = deq_.front();

    deq_.pop_front();

    condProducer_.notify_one();

    return true;

}
```
