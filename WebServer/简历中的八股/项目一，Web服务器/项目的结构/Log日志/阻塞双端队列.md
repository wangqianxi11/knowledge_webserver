---
title: 阻塞双端队列
updated: 2025-04-07T16:31:44
created: 2025-04-07T16:01:03
---

C++类模板：编译器从类模板可以自动生成多个类。
C++类模板的写法如下：
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p></th>
<th><p>template &lt;类型参数表&gt;</p>
<p>class 类模板名{</p>
<p> 成员函数和成员变量</p>
<p>};</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
类模板的成员函数放到类模板定义外面的语法：
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p></th>
<th><p>template &lt;类型参数表&gt;</p>
<p>返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名(参数表)</p>
<p>{</p>
<p> ...</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
用类模板定义对象的写法如下：
| 1   | 类模板名\<真实类型参数表\> 对象名(构造函数实际参数表); |
|-----|--------------------------------------------------------|

阻塞双端队列模板类，用于多线程环境下的生产者-消费者场景
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p></th>
<th><p>template&lt;class T&gt;</p>
<p>class BlockDeque {</p>
<p>public:</p>
<p>explicit BlockDeque(size_t MaxCapacity = 1000);</p>
<p>~BlockDeque();</p>
<p></p>
<p>void clear();</p>
<p>bool empty();</p>
<p>bool full();</p>
<p>void Close();</p>
<p>size_t size();</p>
<p>size_t capacity();</p>
<p>T front();</p>
<p>T back();</p>
<p>void push_back(const T &amp;item);</p>
<p>void push_front(const T &amp;item);</p>
<p>bool pop(T &amp;item);</p>
<p>bool pop(T &amp;item, int timeout);</p>
<p>void flush();</p>
<p></p>
<p>private:</p>
<p>std::deque&lt;T&gt; deq_;</p>
<p>size_t capacity_;</p>
<p>std::mutex mtx_;</p>
<p>bool isClose_;</p>
<p>std::condition_variable condConsumer_;</p>
<p>std::condition_variable condProducer_;</p>
<p>};</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**构造函数和析构函数**
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p></th>
<th><p>template&lt;class T&gt;</p>
<p>BlockDeque&lt;T&gt;::BlockDeque(size_t MaxCapacity) :capacity_(MaxCapacity) {</p>
<p>// 构造函数</p>
<p>isClose_ = false;</p>
<p>}</p>
<p></p>
<p>template&lt;class T&gt;</p>
<p>BlockDeque&lt;T&gt;::~BlockDeque() {</p>
<p>// 析构函数</p>
<p>Close();</p>
<p>};</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**Close()函数关闭阻塞双端队列**
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p></th>
<th><p>template&lt;class T&gt;</p>
<p>void BlockDeque&lt;T&gt;::Close() {</p>
<p>{ // 作用域开始</p>
<p>std::lock_guard&lt;std::mutex&gt; locker(mtx_); // 加锁，确保线程安全</p>
<p>deq_.clear(); // 清空队列</p>
<p>isClose_ = true; // 关闭标志</p>
<p>} // 作用域结束</p>
<p>condProducer_.notify_all(); // 唤醒所有等待的生产者线程</p>
<p>condConsumer_.notify_all(); // 唤醒所有的消费者线程</p>
<p>};</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**向队列尾部添加元素**
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p></th>
<th><p>template&lt;class T&gt;</p>
<p>void BlockDeque&lt;T&gt;::push_back(const T &amp;item) {</p>
<p>// 向双端队列尾部添加</p>
<p>std::unique_lock&lt;std::mutex&gt; locker(mtx_); // 互斥锁保护共享数据</p>
<p>// 检查队列是否已满</p>
<p>while(deq_.size() &gt;= capacity_) {</p>
<p>condProducer_.wait(locker); // 释放锁并等待</p>
<p>}</p>
<p>// 添加</p>
<p>deq_.push_back(item);</p>
<p>condConsumer_.notify_one(); // 唤醒一个消费者线程</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

**从队列头部取出元素，并且允许消费者在指定时间等待元素**
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p></th>
<th><p>template&lt;class T&gt;</p>
<p>bool BlockDeque&lt;T&gt;::pop(T &amp;item, int timeout) {</p>
<p>// 带超时功能的pop方法，运行消费者在指定时间内等待元素</p>
<p>std::unique_lock&lt;std::mutex&gt; locker(mtx_);</p>
<p>while(deq_.empty()){</p>
<p>// 带超时的等待</p>
<p>if(condConsumer_.wait_for(locker, std::chrono::seconds(timeout))</p>
<p>== std::cv_status::timeout){</p>
<p>return false; //超时即返回</p>
<p>}</p>
<p>if(isClose_){</p>
<p>return false;</p>
<p>}</p>
<p>}</p>
<p>item = deq_.front();</p>
<p>deq_.pop_front();</p>
<p>condProducer_.notify_one();</p>
<p>return true;</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

