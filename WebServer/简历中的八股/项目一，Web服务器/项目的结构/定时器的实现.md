---
title: 定时器的实现
updated: 2025-05-19T22:33:52
created: 2025-04-06T15:21:08
---

使用小根堆实现定时器关闭超时的连接，对于非活跃的用户，关闭这个连接，等用户再次需要时重新建立连接

**步骤：**

**1、连接管理：服务器维护一个连接池，包含已建立的连接。**

**2、设置超时时间：每当服务器接受一个新的连接或收到一个请求时，会为该连接设置一个超时时间。这个超时时间通常是从当前时间开始计算的，用于确定连接在多长时间内没有活动会被认为是非活跃连接。**

**3、定时器管理：服务器维护一个小根堆（最小堆），存储了所有连接的超时时间，根据连接的超时时间，保证堆顶元素是最小的超时时间。**

**4、定时器触发：服务器周期性的检查小根堆的堆顶元素，如果发现堆顶元素代表的连接已经超时（即连接变为非活跃状态），则会关闭该连接并从连接池中移除**

**5、调整定时器：如果有新的连接建立或者有活动的连接被检测到，服务器会更新小根堆中相应连接的超时时间。**

**优点：**
- **小根堆的插入、删除和查找最小值的时间复杂度都是O(log n)，**
- **定时器的触发是基于连接的超时时间，提高服务器的响应速度和并发能力**

<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th><p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p></th>
<th><p>struct TimerNode {</p>
<p>/*</p>
<p>@description: 计时器节点，存储相关数据</p>
<p>@id: 计时器的标识符</p>
<p>@expires: 到期时间戳，表示何时触发</p>
<p>@cb：定时器回调函数</p>
<p>@operator&lt;：重载小于号，使能通过expires比较大小</p>
<p>*/</p>
<p>int id;</p>
<p>TimeStamp expires;</p>
<p>TimeoutCallBack cb;</p>
<p>bool operator&lt;(const TimerNode&amp; t) {</p>
<p>return expires &lt; t.expires;</p>
<p>}</p>
<p>};</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
创建这样的计时器节点，最早到期的计时器会排在队列前面

**一、小根堆定时器的时间复杂度**
小根堆以超时时间作为排序依据，堆顶永远是最早超时的连接。
**操作复杂度：**
| **操作**              | **时间复杂度**     |
|-----------------------|--------------------|
| 插入定时器（add）     | O(log N)           |
| 删除定时器（del）     | O(log N)（需定位） |
| 取出堆顶（top）       | O(1)               |
| 取出并删除堆顶（pop） | O(log N)           |
| 定时检查（tick）      | O(log N) 或 O(1)   |

如果你每次 tick()（定时检查）都只处理堆顶一个元素，那么时间复杂度是 **O(log N)**，但处理多个超时任务时会叠加。
**优点：**
- 精度高（毫秒级）
- 实现简单，适用于连接数适中（如 \<10^5）场景
**缺点：**
- 删除某个特定定时器开销较大（需要支持下标定位或懒删除）
- 定时器过多时，插入删除频繁可能造成性能波动

**二、是否考虑过时间轮（Timing Wheel）？**
是的，**时间轮**是一种更高效的定时器管理机制，尤其适合**定时器数量巨大**、**超时时间分布均匀**的场景。
**时间轮原理：**
- 把时间划分成若干个槽位（环形数组）
- 每个槽代表一个时间区间（如 100ms）
- 当前时间指针每次跳一个槽，槽内定时器触发
**时间复杂度：**
| **操作**         | **时间复杂度**   |
|------------------|------------------|
| 插入定时器       | O(1)             |
| 删除定时器       | O(1)（哈希定位） |
| 定时轮转（tick） | O(1)             |

**优点：**
- 插入/删除定时器效率高，适合高并发环境
- 近似 O(1) 的性能，非常适合大型服务器、网络编程
**缺点：**
- 精度受槽大小影响，无法做到毫秒级
- 时间跨度大的定时器不适合（需层级时间轮）
- 实现复杂度比小根堆高

**一、连接超时的处理机制概述**
我们使用 **小根堆定时器** 配合 **Epoll I/O 事件监听** 来处理连接超时：
1.  **每当有新的连接建立或收到活动事件时：**
    - **为该连接创建一个定时器对象，设置超时时间（如 60 秒）**
    - **将该定时器插入小根堆，并记录其对应连接（或通过指针、fd 关联）**
2.  **主线程循环中：**
    - **定时检查堆顶是否超时（当前时间 \> 超时时间）**
    - **若超时，说明连接无活动，执行关闭逻辑：**
      - **从 Epoll 中移除该 fd**
      - **关闭 socket，回收资源**
      - **删除定时器节点**
3.  **每次连接有读写事件发生时：**
    - **延长其定时器（即重设超时时间）**
    - **在小根堆中重新调整其位置（堆调整）**

