---
title: 并发模型
updated: 2025-04-14T21:38:21
created: 2025-04-14T21:31:05
---

**2、几种I/O模型**
**（1）阻塞blocking**
调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。
**（2）非阻塞non-blocking（NIO）**
非阻塞等待，**每隔一段时间**就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成EAGAIN。
**（3）IO复用（IO multiplexing）**
Linux用select/poll/epoll函数实现IO复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数。
多路IO复用是一种同步IO模型，，它可以实现一个线程可以同时监视多个文件描述符，一旦有某个文件描述符准备就绪，就会通知应用程序，对该文件描述符进行操作。在监视的各个文件描述符没有准备就绪的时候，应用程序线程就会阻塞，交出cpu，让cpu去执行其他的任务，以此提高cpu的利用率。
**（4）信号驱动（signal-driven）**
信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO 事件。
与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。
**（5）异步（asynchronous）**
Linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

## 3、简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？主从reactor模型
**事件：I/O事件、信号及定时事件**
（1）reactor模式中，主线程(**I/O处理单元**)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(**逻辑单元**)，将socket可读写事件放入请求队列，交给工作线程处理，即读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由**同步I/O**实现（epoll_wait）。
（2）proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由**异步I/O**实现(aio_read/aio_write)。

## 4、你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？
### （1）epoll的优点：epoll 是一种更加高效的 IO 复用技术
1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；

2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；

即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。

3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。

### epoll 的使用步骤及原理如下：
1）调用epoll_create()会在内核中创建一个指示**epoll内核事件表的文件描述符**，该描述符将用作其他epoll系统调用的第一个参数。
在这个结构体中有 2 个比较重要的数据成员：一个是需要检测的文件描述符的信息 struct_root rbr（红黑树），还有一个是就绪列表struct list_head rdlist，存放检测到数据发送改变的文件描述符信息 （双向链表）；

2）调用epoll_ctl()用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除

3）调用epoll_wait() 可以让内核去检测就绪的事件，并将就绪的事件放到就绪列表中并返回，通过返回的事件数组做进一步的事件处理。

### epoll 的两种工作模式：**
a）LT 模式（水平触发）LT（Level - Triggered）是缺省的工作方式，并且同时支持 Block 和 Nonblock Socket。在这种做法中，内核检测到一个文件描述符就绪了，然后应用程序可以对这个就绪的 fd 进行 IO 操作。应用程序可以不立即处理该事件，如果不作任何操作，内核还是会继续通知。

b）ET 模式（边缘触发）ET（Edge - Triggered）是高速工作方式，只支持**Nonblock socket**。在这种模式下，epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件。必须要一次性将数据读取完，使用非阻塞I/O，读取到出现EAGAIN。但是，如果一直不对这个 fd 进行 IO 操作（从而导致它再次变成未就绪 ），内核不会发送更多的通知（only once）。

ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件描述符的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

3)EPOLLONESHOT
一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket
我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，**当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件**

## select/poll/epoll区别
1）调用函数
select和poll都是一个函数，epoll是一组函数
2）文件描述符数量
select通过**线性表**描述文件描述符集合，文件描述符有上限（与系统内存关系很大），32位机默认是1024个，64位机默认是2048。

poll是**链表**描述，突破了文件描述符上限，最大可以打开文件的数目

epoll通过**红黑树**描述，最大可以打开文件的数目
3）将文件描述符从用户传给内核
select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝

epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上
4）内核判断就绪的文件描述符
select和poll通过线性遍历文件描述符集合，判断哪个文件描述符上有事件发生epoll_create时，内核除了帮我们在epoll文件系统里建了个**红黑树**用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。

epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list
5）应用程序索引就绪文件描述符
select/poll 只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历

epoll 返回的发生了事件的**个数和结构体数组**，结构体包含socket的信息，因此直接处理返回的数组即可
6）工作模式
select和poll都只能工作在相对低效的**LT**模式下

epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。
7）应用场景
当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll

当监测的fd数目较小，且全部fd都比较活跃，建议使用select或者poll

当监测的fd数目非常大，且单位时间只有其中的**一部分fd**处于就绪状态，这个时候使用epoll能够明显提升性能

# 5、LT和ET的使用场景
LT适用于并发量小的情况，ET适用于并发量大的情况。
ET在通知用户之后，就会将fd从就绪链表中删除，而LT不会，它会一直保留，这就会导致随着fd增多，就绪链表越大，每次都要从头开始遍历找到对应的fd，所以并发量越大效率越低。ET因为会删除所以效率比较高。
（LT模式下只读一次，ET模式下是无限循环读）

# 6、怎么解决LT的缺点？
LT模式下，可写状态的 fd 会一直触发事件，该怎么处理这个问题
数据量很少时直接 send 数据，数据量很多时每次要写数据时，将 fd 绑定 EPOLLOUT 事件，写完后将 fd 同 EPOLLOUT 从 epoll 中移除。

# 7、为什么ET模式一定要设置非阻塞？
因为ET模式下是无限循环读，直到出现错误为 EAGAIN 或者 EWOULDBLOCK，这两个错误表示socket 为空，然后就停止循环。如果是阻塞，循环读在 socket 为空的时候就会阻塞到那里，主线程的 read（）函数一旦阻塞住，当再有**其他监听事件**过来就没办法读了，给其他事情造成了影响，所以必须要设置为非阻塞。
**
# 8、epoll 如何判断数据已经读取完成
epoll ET(Edge Trigger)模式，才需要关注数据是否读取完毕了。使用select或者epoll的LT模式，不用关注，select/epoll检测到有数据可读去读就OK了。
两种做法：
1、针对TCP，调用recv方法，根据recv的返回值。如果返回值**小于我们设定的 recv buff 的大小，那么就认为接收完毕。**
2、TCP、UDP都适用，将**socket 设为 NOBLOCK 状态**（使用fcntl函数），然后 selec t该 socket可读的时候，使用**read/recv 函数**读取数据。**当返回值为 -1，并且 errno 是 EAGAIN 或EWOULDBLOCK 的时候，表示数据读取完毕。**

