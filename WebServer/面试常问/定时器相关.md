---
title: 定时器相关
updated: 2025-04-14T21:57:23
created: 2025-04-14T21:53:18
---

# 1、为什么要用定时器？（优化：定时器处理非活跃连接）
为了定期删除非活跃事件，防止连接资源的浪费。
非活跃，是指浏览器与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。
定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。

# 2、说一下定时器的工作原理
定时器利用结构体将定时事件进行封装起来。定时事件，即定期检测非活跃连接。
服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序双向链表将所有定时器串联起来，利用alarm函数周期性地触发SIGALRM信号，信号处理函数利用**管道**通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。
（信号处理函数仅仅发送信号通知程序主循环，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。）
信号通知的逻辑：创建管道，其中管道写端写入信号值，管道读端通过I/O复用系统监测读事件
**为什么管道写端要非阻塞？**
send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。

**5、最小堆优化？说一下时间复杂度和工作原理**
时间复杂度：添加：O(logn)， 删除：O(1)
工作原理：
将所有定时器中**超时时间最小的一个定时器的超时值，作为定时任务处理函数的定时值**。这样，一旦定时任务处理函数被调用，超时时间最小的定时器必然到期，我们就可以在定时任务处理函数中处理该定时器。
然后，再次从剩余的定时器中找出超时时间最小的一个（堆），并将这段最小时间设置为下一次定时任务处理函数的定时值。如此反复，就实现了较为精确的定时。
